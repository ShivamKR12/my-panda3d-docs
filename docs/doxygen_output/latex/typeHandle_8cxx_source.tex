\doxysection{type\+Handle.\+cxx}
\hypertarget{typeHandle_8cxx_source}{}\label{typeHandle_8cxx_source}\index{dtool/src/dtoolbase/typeHandle.cxx@{dtool/src/dtoolbase/typeHandle.cxx}}
\mbox{\hyperlink{typeHandle_8cxx}{Go to the documentation of this file.}}
\begin{DoxyCode}{0}
\DoxyCodeLine{00001\ }
\DoxyCodeLine{00014\ \textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{typeHandle_8h}{typeHandle.h}}"{}}}
\DoxyCodeLine{00015\ \textcolor{preprocessor}{\#include\ "{}\mbox{\hyperlink{typeRegistryNode_8h}{typeRegistryNode.h}}"{}}}
\DoxyCodeLine{00016\ }
\DoxyCodeLine{00022\ \textcolor{keywordtype}{size\_t}\ TypeHandle::}
\DoxyCodeLine{00023\ get\_memory\_usage(MemoryClass\ memory\_class)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00024\ \textcolor{preprocessor}{\#ifdef\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00025\ \ \ assert((\textcolor{keywordtype}{int})memory\_class\ >=\ 0\ \&\&\ (\textcolor{keywordtype}{int})memory\_class\ <\ (\textcolor{keywordtype}{int})MC\_limit);}
\DoxyCodeLine{00026\ \ \ \textcolor{keywordflow}{if}\ ((*\textcolor{keyword}{this})\ ==\ TypeHandle::none())\ \{}
\DoxyCodeLine{00027\ \ \ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{00028\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00029\ \ \ \ \ \mbox{\hyperlink{classTypeRegistryNode}{TypeRegistryNode}}\ *rnode\ =\ TypeRegistry::ptr()-\/>look\_up(*\textcolor{keyword}{this},\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00030\ \ \ \ \ assert(rnode\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00031\ \ \ \ \ \textcolor{keywordflow}{return}\ rnode-\/>\_memory\_usage[memory\_class].load(std::memory\_order\_relaxed);}
\DoxyCodeLine{00032\ \ \ \}}
\DoxyCodeLine{00033\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00034\ \ \ \textcolor{keywordflow}{return}\ 0;}
\DoxyCodeLine{00035\ \}}
\DoxyCodeLine{00036\ }
\DoxyCodeLine{00041\ \textcolor{keywordtype}{void}\ TypeHandle::}
\DoxyCodeLine{00042\ inc\_memory\_usage(MemoryClass\ memory\_class,\ \textcolor{keywordtype}{size\_t}\ size)\ \{}
\DoxyCodeLine{00043\ \textcolor{preprocessor}{\#ifdef\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00044\ \textcolor{preprocessor}{\#ifdef\ \_DEBUG}}
\DoxyCodeLine{00045\ \ \ assert((\textcolor{keywordtype}{int})memory\_class\ >=\ 0\ \&\&\ (\textcolor{keywordtype}{int})memory\_class\ <\ (\textcolor{keywordtype}{int})MC\_limit);}
\DoxyCodeLine{00046\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00047\ \ \ \textcolor{keywordflow}{if}\ ((*\textcolor{keyword}{this})\ !=\ TypeHandle::none())\ \{}
\DoxyCodeLine{00048\ \ \ \ \ \mbox{\hyperlink{classTypeRegistryNode}{TypeRegistryNode}}\ *rnode\ =\ TypeRegistry::ptr()-\/>look\_up(*\textcolor{keyword}{this},\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00049\ \ \ \ \ assert(rnode\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00050\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ prev\ =\ rnode-\/>\_memory\_usage[memory\_class].fetch\_add(size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00051\ \ \ \ \ \textcolor{keywordflow}{if}\ (prev\ +\ size\ <\ prev)\ \{}
\DoxyCodeLine{00052\ \ \ \ \ \ \ std::cerr\ <<\ \textcolor{stringliteral}{"{}Memory\ usage\ overflow\ for\ type\ "{}}\ <<\ rnode-\/>\_name\ <<\ \textcolor{stringliteral}{"{}.\(\backslash\)n"{}};}
\DoxyCodeLine{00053\ \ \ \ \ \ \ abort();}
\DoxyCodeLine{00054\ \ \ \ \ \}}
\DoxyCodeLine{00055\ \ \ \}}
\DoxyCodeLine{00056\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00057\ \}}
\DoxyCodeLine{00058\ }
\DoxyCodeLine{00063\ \textcolor{keywordtype}{void}\ TypeHandle::}
\DoxyCodeLine{00064\ dec\_memory\_usage(MemoryClass\ memory\_class,\ \textcolor{keywordtype}{size\_t}\ size)\ \{}
\DoxyCodeLine{00065\ \textcolor{preprocessor}{\#ifdef\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00066\ \textcolor{preprocessor}{\#ifdef\ \_DEBUG}}
\DoxyCodeLine{00067\ \ \ assert((\textcolor{keywordtype}{int})memory\_class\ >=\ 0\ \&\&\ (\textcolor{keywordtype}{int})memory\_class\ <\ (\textcolor{keywordtype}{int})MC\_limit);}
\DoxyCodeLine{00068\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00069\ \ \ \textcolor{keywordflow}{if}\ ((*\textcolor{keyword}{this})\ !=\ TypeHandle::none())\ \{}
\DoxyCodeLine{00070\ \ \ \ \ \mbox{\hyperlink{classTypeRegistryNode}{TypeRegistryNode}}\ *rnode\ =\ TypeRegistry::ptr()-\/>look\_up(*\textcolor{keyword}{this},\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00071\ \ \ \ \ assert(rnode\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00072\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ prev\ =\ rnode-\/>\_memory\_usage[memory\_class].fetch\_sub(size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00073\ \ \ \ \ assert(prev\ -\/\ size\ <=\ prev);}
\DoxyCodeLine{00074\ \ \ \}}
\DoxyCodeLine{00075\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00076\ \}}
\DoxyCodeLine{00077\ }
\DoxyCodeLine{00082\ \textcolor{keywordtype}{void}\ *\mbox{\hyperlink{classTypeHandle_ae7476081f780a4321a4ae0010a0c1a7d}{TypeHandle::}}}
\DoxyCodeLine{00083\ \mbox{\hyperlink{classTypeHandle_ae7476081f780a4321a4ae0010a0c1a7d}{allocate\_array}}(\textcolor{keywordtype}{size\_t}\ size)\ \{}
\DoxyCodeLine{00084\ \ \ TAU\_PROFILE(\textcolor{stringliteral}{"{}TypeHandle:allocate\_array()"{}},\ \textcolor{stringliteral}{"{}\ "{}},\ TAU\_USER);}
\DoxyCodeLine{00085\ }
\DoxyCodeLine{00086\ \ \ \textcolor{keywordtype}{void}\ *ptr\ =\ PANDA\_MALLOC\_ARRAY(size);}
\DoxyCodeLine{00087\ \textcolor{preprocessor}{\#ifdef\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00088\ \ \ \textcolor{keywordflow}{if}\ ((*\textcolor{keyword}{this})\ !=\ TypeHandle::none())\ \{}
\DoxyCodeLine{00089\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ alloc\_size\ =\ MemoryHook::get\_ptr\_size(ptr);}
\DoxyCodeLine{00090\ \textcolor{preprocessor}{\#ifdef\ \_DEBUG}}
\DoxyCodeLine{00091\ \ \ \ \ assert(size\ <=\ alloc\_size);}
\DoxyCodeLine{00092\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00093\ \ \ \ \ \mbox{\hyperlink{classTypeRegistryNode}{TypeRegistryNode}}\ *rnode\ =\ TypeRegistry::ptr()-\/>look\_up(*\textcolor{keyword}{this},\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00094\ \ \ \ \ assert(rnode\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00095\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ prev\ =\ rnode-\/>\_memory\_usage[MC\_array].fetch\_add(alloc\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00096\ \ \ \ \ \textcolor{keywordflow}{if}\ (prev\ +\ size\ <\ prev)\ \{}
\DoxyCodeLine{00097\ \ \ \ \ \ \ std::cerr\ <<\ \textcolor{stringliteral}{"{}Memory\ usage\ overflow\ for\ type\ "{}}\ <<\ rnode-\/>\_name\ <<\ \textcolor{stringliteral}{"{}.\(\backslash\)n"{}};}
\DoxyCodeLine{00098\ \ \ \ \ \ \ abort();}
\DoxyCodeLine{00099\ \ \ \ \ \}}
\DoxyCodeLine{00100\ \ \ \}}
\DoxyCodeLine{00101\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00102\ \ \ \textcolor{keywordflow}{return}\ ptr;}
\DoxyCodeLine{00103\ \}}
\DoxyCodeLine{00104\ }
\DoxyCodeLine{00109\ \textcolor{keywordtype}{void}\ *\mbox{\hyperlink{classTypeHandle_ac9146f32b539675b1c955517cd9cb1d4}{TypeHandle::}}}
\DoxyCodeLine{00110\ \mbox{\hyperlink{classTypeHandle_ac9146f32b539675b1c955517cd9cb1d4}{reallocate\_array}}(\textcolor{keywordtype}{void}\ *old\_ptr,\ \textcolor{keywordtype}{size\_t}\ size)\ \{}
\DoxyCodeLine{00111\ \ \ TAU\_PROFILE(\textcolor{stringliteral}{"{}TypeHandle:reallocate\_array()"{}},\ \textcolor{stringliteral}{"{}\ "{}},\ TAU\_USER);}
\DoxyCodeLine{00112\ }
\DoxyCodeLine{00113\ \textcolor{preprocessor}{\#ifdef\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00114\ \ \ \textcolor{keywordtype}{size\_t}\ old\_size\ =\ MemoryHook::get\_ptr\_size(old\_ptr);}
\DoxyCodeLine{00115\ \ \ \textcolor{keywordtype}{void}\ *new\_ptr\ =\ PANDA\_REALLOC\_ARRAY(old\_ptr,\ size);}
\DoxyCodeLine{00116\ }
\DoxyCodeLine{00117\ \ \ \textcolor{keywordflow}{if}\ ((*\textcolor{keyword}{this})\ !=\ TypeHandle::none())\ \{}
\DoxyCodeLine{00118\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ new\_size\ =\ MemoryHook::get\_ptr\_size(new\_ptr);}
\DoxyCodeLine{00119\ }
\DoxyCodeLine{00120\ \ \ \ \ \mbox{\hyperlink{classTypeRegistryNode}{TypeRegistryNode}}\ *rnode\ =\ TypeRegistry::ptr()-\/>look\_up(*\textcolor{keyword}{this},\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00121\ \ \ \ \ assert(rnode\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00122\ \ \ \ \ \textcolor{keywordflow}{if}\ (new\_size\ >\ old\_size)\ \{}
\DoxyCodeLine{00123\ \ \ \ \ \ \ rnode-\/>\_memory\_usage[MC\_array].fetch\_add(new\_size\ -\/\ old\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00124\ \ \ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00125\ \ \ \ \ \ \ rnode-\/>\_memory\_usage[MC\_array].fetch\_sub(old\_size\ -\/\ new\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00126\ \ \ \ \ \}}
\DoxyCodeLine{00127\ \ \ \}}
\DoxyCodeLine{00128\ \textcolor{preprocessor}{\#else}}
\DoxyCodeLine{00129\ \ \ \textcolor{keywordtype}{void}\ *new\_ptr\ =\ PANDA\_REALLOC\_ARRAY(old\_ptr,\ size);}
\DoxyCodeLine{00130\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00131\ \ \ \textcolor{keywordflow}{return}\ new\_ptr;}
\DoxyCodeLine{00132\ \}}
\DoxyCodeLine{00133\ }
\DoxyCodeLine{00138\ \textcolor{keywordtype}{void}\ \mbox{\hyperlink{classTypeHandle_a532dfc7c439beb0aadb5ed26781b35c8}{TypeHandle::}}}
\DoxyCodeLine{00139\ \mbox{\hyperlink{classTypeHandle_a532dfc7c439beb0aadb5ed26781b35c8}{deallocate\_array}}(\textcolor{keywordtype}{void}\ *ptr)\ \{}
\DoxyCodeLine{00140\ \ \ TAU\_PROFILE(\textcolor{stringliteral}{"{}TypeHandle:deallocate\_array()"{}},\ \textcolor{stringliteral}{"{}\ "{}},\ TAU\_USER);}
\DoxyCodeLine{00141\ }
\DoxyCodeLine{00142\ \textcolor{preprocessor}{\#ifdef\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00143\ \ \ \textcolor{keywordtype}{size\_t}\ alloc\_size\ =\ MemoryHook::get\_ptr\_size(ptr);}
\DoxyCodeLine{00144\ \ \ \textcolor{keywordflow}{if}\ ((*\textcolor{keyword}{this})\ !=\ TypeHandle::none())\ \{}
\DoxyCodeLine{00145\ \ \ \ \ \mbox{\hyperlink{classTypeRegistryNode}{TypeRegistryNode}}\ *rnode\ =\ TypeRegistry::ptr()-\/>look\_up(*\textcolor{keyword}{this},\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00146\ \ \ \ \ assert(rnode\ !=\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00147\ \ \ \ \ \textcolor{keywordtype}{size\_t}\ prev\ =\ rnode-\/>\_memory\_usage[MC\_array].fetch\_sub(alloc\_size,\ std::memory\_order\_relaxed);}
\DoxyCodeLine{00148\ \ \ \ \ assert(prev\ -\/\ alloc\_size\ <=\ prev);}
\DoxyCodeLine{00149\ \ \ \}}
\DoxyCodeLine{00150\ \textcolor{preprocessor}{\#endif\ \ }\textcolor{comment}{//\ DO\_MEMORY\_USAGE}}
\DoxyCodeLine{00151\ \ \ PANDA\_FREE\_ARRAY(ptr);}
\DoxyCodeLine{00152\ \}}
\DoxyCodeLine{00153\ }
\DoxyCodeLine{00154\ \textcolor{preprocessor}{\#ifdef\ HAVE\_PYTHON}}
\DoxyCodeLine{00158\ PyTypeObject\ *TypeHandle::}
\DoxyCodeLine{00159\ get\_python\_type()\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00160\ \ \ \mbox{\hyperlink{classTypeRegistryNode}{TypeRegistryNode}}\ *rnode\ =\ TypeRegistry::ptr()-\/>look\_up(*\textcolor{keyword}{this},\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00161\ \ \ \textcolor{keywordflow}{if}\ (rnode\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00162\ \ \ \ \ \textcolor{keywordflow}{return}\ rnode-\/>get\_python\_type();}
\DoxyCodeLine{00163\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00164\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00165\ \ \ \}}
\DoxyCodeLine{00166\ \}}
\DoxyCodeLine{00167\ }
\DoxyCodeLine{00171\ PyObject\ *TypeHandle::}
\DoxyCodeLine{00172\ wrap\_python(\textcolor{keywordtype}{void}\ *ptr,\ PyTypeObject\ *cast\_from)\textcolor{keyword}{\ const\ }\{}
\DoxyCodeLine{00173\ \ \ \textcolor{keywordflow}{if}\ (ptr\ ==\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00174\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00175\ \ \ \}}
\DoxyCodeLine{00176\ \ \ \mbox{\hyperlink{classTypeRegistryNode}{TypeRegistryNode}}\ *rnode\ =\ TypeRegistry::ptr()-\/>look\_up(*\textcolor{keyword}{this},\ \textcolor{keyword}{nullptr});}
\DoxyCodeLine{00177\ \ \ \textcolor{keywordflow}{if}\ (rnode\ !=\ \textcolor{keyword}{nullptr})\ \{}
\DoxyCodeLine{00178\ \ \ \ \ \textcolor{keywordflow}{return}\ rnode-\/>wrap\_python(ptr,\ cast\_from);}
\DoxyCodeLine{00179\ \ \ \}\ \textcolor{keywordflow}{else}\ \{}
\DoxyCodeLine{00180\ \ \ \ \ \textcolor{keywordflow}{return}\ \textcolor{keyword}{nullptr};}
\DoxyCodeLine{00181\ \ \ \}}
\DoxyCodeLine{00182\ \}}
\DoxyCodeLine{00183\ \textcolor{preprocessor}{\#endif}}
\DoxyCodeLine{00184\ }
\DoxyCodeLine{00185\ std::ostream\ \&}
\DoxyCodeLine{00186\ operator\ <<\ (std::ostream\ \&out,\ TypeHandle::MemoryClass\ mem\_class)\ \{}
\DoxyCodeLine{00187\ \ \ \textcolor{keywordflow}{switch}\ (mem\_class)\ \{}
\DoxyCodeLine{00188\ \ \ \textcolor{keywordflow}{case}\ TypeHandle::MC\_singleton:}
\DoxyCodeLine{00189\ \ \ \ \ \textcolor{keywordflow}{return}\ out\ <<\ \textcolor{stringliteral}{"{}singleton"{}};}
\DoxyCodeLine{00190\ }
\DoxyCodeLine{00191\ \ \ \textcolor{keywordflow}{case}\ TypeHandle::MC\_array:}
\DoxyCodeLine{00192\ \ \ \ \ \textcolor{keywordflow}{return}\ out\ <<\ \textcolor{stringliteral}{"{}array"{}};}
\DoxyCodeLine{00193\ }
\DoxyCodeLine{00194\ \ \ \textcolor{keywordflow}{case}\ TypeHandle::MC\_deleted\_chain\_active:}
\DoxyCodeLine{00195\ \ \ \ \ \textcolor{keywordflow}{return}\ out\ <<\ \textcolor{stringliteral}{"{}deleted\_chain\_active"{}};}
\DoxyCodeLine{00196\ }
\DoxyCodeLine{00197\ \ \ \textcolor{keywordflow}{case}\ TypeHandle::MC\_deleted\_chain\_inactive:}
\DoxyCodeLine{00198\ \ \ \ \ \textcolor{keywordflow}{return}\ out\ <<\ \textcolor{stringliteral}{"{}deleted\_chain\_inactive"{}};}
\DoxyCodeLine{00199\ }
\DoxyCodeLine{00200\ \ \ \textcolor{keywordflow}{case}\ TypeHandle::MC\_limit:}
\DoxyCodeLine{00201\ \ \ \ \ \textcolor{keywordflow}{return}\ out\ <<\ \textcolor{stringliteral}{"{}limit"{}};}
\DoxyCodeLine{00202\ \ \ \}}
\DoxyCodeLine{00203\ }
\DoxyCodeLine{00204\ \ \ \textcolor{keywordflow}{return}\ out}
\DoxyCodeLine{00205\ \ \ \ \ <<\ \textcolor{stringliteral}{"{}**invalid\ TypeHandle::MemoryClass\ ("{}}\ <<\ (int)mem\_class}
\DoxyCodeLine{00206\ \ \ \ \ <<\ \textcolor{stringliteral}{"{})**\(\backslash\)n"{}};}
\DoxyCodeLine{00207\ \}}

\end{DoxyCode}
