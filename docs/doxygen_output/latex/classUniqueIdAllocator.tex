\doxysection{Unique\+Id\+Allocator Class Reference}
\hypertarget{classUniqueIdAllocator}{}\label{classUniqueIdAllocator}\index{UniqueIdAllocator@{UniqueIdAllocator}}


{\ttfamily \#include $<$unique\+Id\+Allocator.\+h$>$}

\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classUniqueIdAllocator_a37dcbe59966fafb0fea76b2fbccfe7d7}\label{classUniqueIdAllocator_a37dcbe59966fafb0fea76b2fbccfe7d7} 
static const uint32\+\_\+t {\bfseries Index\+End} = (uint32\+\_\+t)-\/1
\item 
\Hypertarget{classUniqueIdAllocator_ac94b0779fafd438d7950231c5c6cc2a2}\label{classUniqueIdAllocator_ac94b0779fafd438d7950231c5c6cc2a2} 
static const uint32\+\_\+t {\bfseries Index\+Allocated} = (uint32\+\_\+t)-\/2
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classUniqueIdAllocator_a7fa69a67eec4fad69079395deefde97a}\label{classUniqueIdAllocator_a7fa69a67eec4fad69079395deefde97a} 
uint32\+\_\+t \texorpdfstring{$\ast$}{*} {\bfseries \+\_\+table}
\item 
\Hypertarget{classUniqueIdAllocator_abb37e778e1ff0f1ee3d41bd45039d16a}\label{classUniqueIdAllocator_abb37e778e1ff0f1ee3d41bd45039d16a} 
uint32\+\_\+t {\bfseries \+\_\+min}
\item 
\Hypertarget{classUniqueIdAllocator_aad9c378797294bb7735173c68a453686}\label{classUniqueIdAllocator_aad9c378797294bb7735173c68a453686} 
uint32\+\_\+t {\bfseries \+\_\+max}
\item 
\Hypertarget{classUniqueIdAllocator_af714fd24cb1be66bc32a07e020611a0a}\label{classUniqueIdAllocator_af714fd24cb1be66bc32a07e020611a0a} 
uint32\+\_\+t {\bfseries \+\_\+next\+\_\+free}
\item 
\Hypertarget{classUniqueIdAllocator_aeccb90e2288f0bc14a69aa869dfd433d}\label{classUniqueIdAllocator_aeccb90e2288f0bc14a69aa869dfd433d} 
uint32\+\_\+t {\bfseries \+\_\+last\+\_\+free}
\item 
\Hypertarget{classUniqueIdAllocator_a879b9a1cb6f0c5d1fb35cf5439262dfc}\label{classUniqueIdAllocator_a879b9a1cb6f0c5d1fb35cf5439262dfc} 
uint32\+\_\+t {\bfseries \+\_\+size}
\item 
\Hypertarget{classUniqueIdAllocator_aa40091615a993e78e1ccc12b99920a25}\label{classUniqueIdAllocator_aa40091615a993e78e1ccc12b99920a25} 
uint32\+\_\+t {\bfseries \+\_\+free}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Manage a set of ID values from min to max inclusive. The ID numbers that are freed will be allocated (reused) in the same order. I.\+e. the oldest ID numbers will be allocated.

This implementation will use 4 bytes per id number, plus a few bytes of management data. e.\+g. 10,000 ID numbers will use 40KB.

Also be advised that ID -\/1 and -\/2 are used internally by the allocator. If allocate returns Index\+End (-\/1) then the allocator is out of free ID numbers.

There are other implementations that can better leverage runs of used or unused IDs or use bit arrays for the IDs. But, it takes extra work to track the age of freed IDs, which is required for what we wanted. If you would like to kick around other implementation ideas, please contact Schuyler. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
panda/src/putil/\mbox{\hyperlink{uniqueIdAllocator_8h}{unique\+Id\+Allocator.\+h}}\item 
panda/src/putil/\mbox{\hyperlink{uniqueIdAllocator_8cxx}{unique\+Id\+Allocator.\+cxx}}\end{DoxyCompactItemize}
