\doxysection{Memory\+Hook Class Reference}
\hypertarget{classMemoryHook}{}\label{classMemoryHook}\index{MemoryHook@{MemoryHook}}


{\ttfamily \#include $<$memory\+Hook.\+h$>$}

Inheritance diagram for Memory\+Hook\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classMemoryHook}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classMemoryHook_af98a6c8f454aa1a4aa7f8cf7b9cc5203}\label{classMemoryHook_af98a6c8f454aa1a4aa7f8cf7b9cc5203} 
{\bfseries Memory\+Hook} (const \mbox{\hyperlink{classMemoryHook}{Memory\+Hook}} \&copy)
\item 
virtual void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classMemoryHook_a7555492ddf2d21b4e4257b4492532ed7}{heap\+\_\+alloc\+\_\+single}} (size\+\_\+t size)
\item 
virtual void \mbox{\hyperlink{classMemoryHook_a898d872432e052aaa04113be37b53fa5}{heap\+\_\+free\+\_\+single}} (void \texorpdfstring{$\ast$}{*}ptr)
\item 
virtual void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classMemoryHook_a48f518b2d475945b0e0dc4f256c68626}{heap\+\_\+alloc\+\_\+array}} (size\+\_\+t size)
\item 
virtual void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classMemoryHook_ab6dd724d878249f8902bab6d51e96b72}{heap\+\_\+realloc\+\_\+array}} (void \texorpdfstring{$\ast$}{*}ptr, size\+\_\+t size)
\item 
virtual void \mbox{\hyperlink{classMemoryHook_a6c1598f606ff745dc1cb1e2c593ebd47}{heap\+\_\+free\+\_\+array}} (void \texorpdfstring{$\ast$}{*}ptr)
\item 
\Hypertarget{classMemoryHook_a5d0fcacba846ad0f1ce456fa01e10c6c}\label{classMemoryHook_a5d0fcacba846ad0f1ce456fa01e10c6c} 
INLINE void {\bfseries inc\+\_\+heap} (size\+\_\+t size)
\item 
\Hypertarget{classMemoryHook_abf74987d0734fc62aa1316072030c806}\label{classMemoryHook_abf74987d0734fc62aa1316072030c806} 
INLINE void {\bfseries dec\+\_\+heap} (size\+\_\+t size)
\item 
bool \mbox{\hyperlink{classMemoryHook_aacb42686df80c3f38bbaa59232d71f29}{heap\+\_\+trim}} (size\+\_\+t pad)
\item 
virtual void \texorpdfstring{$\ast$}{*} \mbox{\hyperlink{classMemoryHook_a1bf6209c089890e81f127b4f1f429cb8}{mmap\+\_\+alloc}} (size\+\_\+t size, bool allow\+\_\+exec)
\item 
virtual void \mbox{\hyperlink{classMemoryHook_a1db3083e6f6274e9e94b4171f36f7163}{mmap\+\_\+free}} (void \texorpdfstring{$\ast$}{*}ptr, size\+\_\+t size)
\item 
\Hypertarget{classMemoryHook_ad2aa42e398078bf323d616bba1484ebe}\label{classMemoryHook_ad2aa42e398078bf323d616bba1484ebe} 
INLINE size\+\_\+t {\bfseries get\+\_\+page\+\_\+size} () const
\item 
\Hypertarget{classMemoryHook_a947b6cea69d162e6c3b892af312f50a3}\label{classMemoryHook_a947b6cea69d162e6c3b892af312f50a3} 
INLINE size\+\_\+t {\bfseries round\+\_\+up\+\_\+to\+\_\+page\+\_\+size} (size\+\_\+t size) const
\item 
virtual void \mbox{\hyperlink{classMemoryHook_a7d3d40238b568141a6fedfc8f58f9202}{mark\+\_\+pointer}} (void \texorpdfstring{$\ast$}{*}ptr, size\+\_\+t orig\+\_\+size, \mbox{\hyperlink{classReferenceCount}{Reference\+Count}} \texorpdfstring{$\ast$}{*}ref\+\_\+ptr)
\item 
virtual void \mbox{\hyperlink{classMemoryHook_a3ca590278137439b1f3b12a5ac896bf9}{alloc\+\_\+fail}} (size\+\_\+t attempted\+\_\+size)
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classMemoryHook_ae0e773749c197162f7166bec7e1d0baa}\label{classMemoryHook_ae0e773749c197162f7166bec7e1d0baa} 
static constexpr size\+\_\+t {\bfseries get\+\_\+memory\+\_\+alignment} ()
\item 
\Hypertarget{classMemoryHook_aa7319c9d2911cc0836ad5eb7fa596e9d}\label{classMemoryHook_aa7319c9d2911cc0836ad5eb7fa596e9d} 
static INLINE size\+\_\+t {\bfseries get\+\_\+ptr\+\_\+size} (void \texorpdfstring{$\ast$}{*}ptr)
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \mbox{\hyperlink{classMemoryHook_a384863305e12229f4f5e9d292c2e8146}{overflow\+\_\+heap\+\_\+size}} ()
\item 
void \mbox{\hyperlink{classMemoryHook_a50fbd1025459bf0cfd59cbce39e506d9}{determine\+\_\+page\+\_\+size}} () const
\end{DoxyCompactItemize}
\doxysubsubsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classMemoryHook_a9785a140537d3d450c5d52a650617387}\label{classMemoryHook_a9785a140537d3d450c5d52a650617387} 
\mbox{\hyperlink{structpatomic}{patomic}}$<$ size\+\_\+t $>$ {\bfseries \+\_\+total\+\_\+heap\+\_\+single\+\_\+size} \{ 0u \}
\item 
\Hypertarget{classMemoryHook_a1229495e50ba850768b259b14a151f35}\label{classMemoryHook_a1229495e50ba850768b259b14a151f35} 
\mbox{\hyperlink{structpatomic}{patomic}}$<$ size\+\_\+t $>$ {\bfseries \+\_\+total\+\_\+heap\+\_\+array\+\_\+size} \{ 0u \}
\item 
\Hypertarget{classMemoryHook_ad489330b5e7ce65c580a2ff4da5da1f7}\label{classMemoryHook_ad489330b5e7ce65c580a2ff4da5da1f7} 
\mbox{\hyperlink{structpatomic}{patomic}}$<$ size\+\_\+t $>$ {\bfseries \+\_\+requested\+\_\+heap\+\_\+size} \{ 0u \}
\item 
\Hypertarget{classMemoryHook_a37be7726f3804ea39dc686ca7da58125}\label{classMemoryHook_a37be7726f3804ea39dc686ca7da58125} 
\mbox{\hyperlink{structpatomic}{patomic}}$<$ size\+\_\+t $>$ {\bfseries \+\_\+total\+\_\+mmap\+\_\+size} \{ 0u \}
\item 
\Hypertarget{classMemoryHook_a9158e5b94c66870a049451dc8459c02e}\label{classMemoryHook_a9158e5b94c66870a049451dc8459c02e} 
size\+\_\+t {\bfseries \+\_\+max\+\_\+heap\+\_\+size} = \texorpdfstring{$\sim$}{\string~}(size\+\_\+t)0
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
This class provides a wrapper around the various possible malloc schemes Panda might employ. It also exists to allow the \doxylink{classMemoryUsage}{Memory\+Usage} class in Panda to insert callback hooks to track the size of allocated pointers.

The PANDA\+\_\+\+MALLOC\+\_\+\texorpdfstring{$\ast$}{*} and PANDA\+\_\+\+FREE\+\_\+\texorpdfstring{$\ast$}{*} macros are defined to vector through through this class (except in production builds) to facilitate that. Every memory allocation call in Panda should therefore use these macros instead of direct calls to malloc or free. (C++ new and delete operators may be employed for classes which inherit from \doxylink{classMemoryBase}{Memory\+Base}; otherwise, use the PANDA\+\_\+\+MALLOC macros.) 

\doxysubsection{Member Function Documentation}
\Hypertarget{classMemoryHook_a3ca590278137439b1f3b12a5ac896bf9}\label{classMemoryHook_a3ca590278137439b1f3b12a5ac896bf9} 
\index{MemoryHook@{MemoryHook}!alloc\_fail@{alloc\_fail}}
\index{alloc\_fail@{alloc\_fail}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{alloc\_fail()}{alloc\_fail()}}
{\footnotesize\ttfamily void Memory\+Hook\+::alloc\+\_\+fail (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{attempted\+\_\+size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

This callback method is called whenever a low-\/level call to call\+\_\+malloc() has returned NULL, indicating failure.

Since this method is called very low-\/level, and may be in the middle of any number of critical sections, it will be difficult for this callback initiate any emergency high-\/level operation to make more memory available. However, this module is set up to assume that that\textquotesingle{}s what this method does, and will make another alloc attempt after it returns. Probably the only sensible thing this method can do, however, is just to display a message and abort. \Hypertarget{classMemoryHook_a50fbd1025459bf0cfd59cbce39e506d9}\label{classMemoryHook_a50fbd1025459bf0cfd59cbce39e506d9} 
\index{MemoryHook@{MemoryHook}!determine\_page\_size@{determine\_page\_size}}
\index{determine\_page\_size@{determine\_page\_size}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{determine\_page\_size()}{determine\_page\_size()}}
{\footnotesize\ttfamily void Memory\+Hook\+::determine\+\_\+page\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption}) const\hspace{0.3cm}{\ttfamily [protected]}}

Asks the operating system for the page size. \Hypertarget{classMemoryHook_a48f518b2d475945b0e0dc4f256c68626}\label{classMemoryHook_a48f518b2d475945b0e0dc4f256c68626} 
\index{MemoryHook@{MemoryHook}!heap\_alloc\_array@{heap\_alloc\_array}}
\index{heap\_alloc\_array@{heap\_alloc\_array}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{heap\_alloc\_array()}{heap\_alloc\_array()}}
{\footnotesize\ttfamily void \texorpdfstring{$\ast$}{*} Memory\+Hook\+::heap\+\_\+alloc\+\_\+array (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Allocates a block of memory from the heap, similar to malloc(). This will never return NULL; it will abort instead if memory is not available.

This particular function should be used to allocate memory for an array of objects, as opposed to a single object. The only difference is in the bookkeeping. 

Reimplemented in \mbox{\hyperlink{classMemoryUsage_ac19a2d0adf46d3f4bc14184c62ab19af}{Memory\+Usage}}.

\Hypertarget{classMemoryHook_a7555492ddf2d21b4e4257b4492532ed7}\label{classMemoryHook_a7555492ddf2d21b4e4257b4492532ed7} 
\index{MemoryHook@{MemoryHook}!heap\_alloc\_single@{heap\_alloc\_single}}
\index{heap\_alloc\_single@{heap\_alloc\_single}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{heap\_alloc\_single()}{heap\_alloc\_single()}}
{\footnotesize\ttfamily void \texorpdfstring{$\ast$}{*} Memory\+Hook\+::heap\+\_\+alloc\+\_\+single (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Allocates a block of memory from the heap, similar to malloc(). This will never return NULL; it will abort instead if memory is not available.

This particular function should be used to allocate memory for a single object, as opposed to an array. The only difference is in the bookkeeping. 

Reimplemented in \mbox{\hyperlink{classMemoryUsage_a83b32436dd9cee3d5b59dec22a203703}{Memory\+Usage}}.

\Hypertarget{classMemoryHook_a6c1598f606ff745dc1cb1e2c593ebd47}\label{classMemoryHook_a6c1598f606ff745dc1cb1e2c593ebd47} 
\index{MemoryHook@{MemoryHook}!heap\_free\_array@{heap\_free\_array}}
\index{heap\_free\_array@{heap\_free\_array}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{heap\_free\_array()}{heap\_free\_array()}}
{\footnotesize\ttfamily void Memory\+Hook\+::heap\+\_\+free\+\_\+array (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Releases a block of memory previously allocated via heap\+\_\+alloc\+\_\+array. 

Reimplemented in \mbox{\hyperlink{classMemoryUsage_a7dda729b0c75618360ea928538bba294}{Memory\+Usage}}.

\Hypertarget{classMemoryHook_a898d872432e052aaa04113be37b53fa5}\label{classMemoryHook_a898d872432e052aaa04113be37b53fa5} 
\index{MemoryHook@{MemoryHook}!heap\_free\_single@{heap\_free\_single}}
\index{heap\_free\_single@{heap\_free\_single}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{heap\_free\_single()}{heap\_free\_single()}}
{\footnotesize\ttfamily void Memory\+Hook\+::heap\+\_\+free\+\_\+single (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}}]{ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Releases a block of memory previously allocated via heap\+\_\+alloc\+\_\+single. 

Reimplemented in \mbox{\hyperlink{classMemoryUsage_a5fd057965df5b3b88181dba761c66ba0}{Memory\+Usage}}.

\Hypertarget{classMemoryHook_ab6dd724d878249f8902bab6d51e96b72}\label{classMemoryHook_ab6dd724d878249f8902bab6d51e96b72} 
\index{MemoryHook@{MemoryHook}!heap\_realloc\_array@{heap\_realloc\_array}}
\index{heap\_realloc\_array@{heap\_realloc\_array}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{heap\_realloc\_array()}{heap\_realloc\_array()}}
{\footnotesize\ttfamily void \texorpdfstring{$\ast$}{*} Memory\+Hook\+::heap\+\_\+realloc\+\_\+array (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}}]{ptr,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Resizes a block of memory previously returned from heap\+\_\+alloc\+\_\+array. 

Reimplemented in \mbox{\hyperlink{classMemoryUsage_a76cb17df1b567caa751a716529c1d7e2}{Memory\+Usage}}.

\Hypertarget{classMemoryHook_aacb42686df80c3f38bbaa59232d71f29}\label{classMemoryHook_aacb42686df80c3f38bbaa59232d71f29} 
\index{MemoryHook@{MemoryHook}!heap\_trim@{heap\_trim}}
\index{heap\_trim@{heap\_trim}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{heap\_trim()}{heap\_trim()}}
{\footnotesize\ttfamily bool Memory\+Hook\+::heap\+\_\+trim (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{pad }\end{DoxyParamCaption})}

Attempts to release memory back to the system, if possible. The pad argument is the minimum amount of unused memory to keep in the heap (against future allocations). Any memory above that may be released to the system, reducing the memory size of this process. There is no guarantee that any memory may be released.

Returns true if any memory was actually released, false otherwise. \Hypertarget{classMemoryHook_a7d3d40238b568141a6fedfc8f58f9202}\label{classMemoryHook_a7d3d40238b568141a6fedfc8f58f9202} 
\index{MemoryHook@{MemoryHook}!mark\_pointer@{mark\_pointer}}
\index{mark\_pointer@{mark\_pointer}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{mark\_pointer()}{mark\_pointer()}}
{\footnotesize\ttfamily void Memory\+Hook\+::mark\+\_\+pointer (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}}]{ptr,  }\item[{size\+\_\+t}]{orig\+\_\+size,  }\item[{\mbox{\hyperlink{classReferenceCount}{Reference\+Count}} \texorpdfstring{$\ast$}{*}}]{ref\+\_\+ptr }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

This special method exists only to provide a callback hook into \doxylink{classMemoryUsage}{Memory\+Usage}. It indicates that the indicated pointer, allocated from somewhere other than a call to heap\+\_\+alloc(), now contains a pointer to the indicated \doxylink{classReferenceCount}{Reference\+Count} object. If orig\+\_\+size is 0, it indicates that the \doxylink{classReferenceCount}{Reference\+Count} object has been destroyed. 

Reimplemented in \mbox{\hyperlink{classMemoryUsage_ad631b7a26b1eb7476ce9999e687addf8}{Memory\+Usage}}.

\Hypertarget{classMemoryHook_a1bf6209c089890e81f127b4f1f429cb8}\label{classMemoryHook_a1bf6209c089890e81f127b4f1f429cb8} 
\index{MemoryHook@{MemoryHook}!mmap\_alloc@{mmap\_alloc}}
\index{mmap\_alloc@{mmap\_alloc}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{mmap\_alloc()}{mmap\_alloc()}}
{\footnotesize\ttfamily void \texorpdfstring{$\ast$}{*} Memory\+Hook\+::mmap\+\_\+alloc (\begin{DoxyParamCaption}\item[{size\+\_\+t}]{size,  }\item[{bool}]{allow\+\_\+exec }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Allocates a raw page or pages of memory directly from the OS. This will be in a different address space from the memory allocated by heap\+\_\+alloc(), and so it won\textquotesingle{}t contribute to fragmentation of that memory.

The allocation size must be an integer multiple of the page size. Use round\+\_\+to\+\_\+page\+\_\+size() if there is any doubt.

If allow\+\_\+exec is true, the memory will be flagged so that it is legal to execute code that has been written to this memory. \Hypertarget{classMemoryHook_a1db3083e6f6274e9e94b4171f36f7163}\label{classMemoryHook_a1db3083e6f6274e9e94b4171f36f7163} 
\index{MemoryHook@{MemoryHook}!mmap\_free@{mmap\_free}}
\index{mmap\_free@{mmap\_free}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{mmap\_free()}{mmap\_free()}}
{\footnotesize\ttfamily void Memory\+Hook\+::mmap\+\_\+free (\begin{DoxyParamCaption}\item[{void \texorpdfstring{$\ast$}{*}}]{ptr,  }\item[{size\+\_\+t}]{size }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [virtual]}}

Frees a block of memory previously allocated via \doxylink{classMemoryHook_a1bf6209c089890e81f127b4f1f429cb8}{mmap\+\_\+alloc()}. You must know how large the block was. \Hypertarget{classMemoryHook_a384863305e12229f4f5e9d292c2e8146}\label{classMemoryHook_a384863305e12229f4f5e9d292c2e8146} 
\index{MemoryHook@{MemoryHook}!overflow\_heap\_size@{overflow\_heap\_size}}
\index{overflow\_heap\_size@{overflow\_heap\_size}!MemoryHook@{MemoryHook}}
\doxysubsubsection{\texorpdfstring{overflow\_heap\_size()}{overflow\_heap\_size()}}
{\footnotesize\ttfamily void Memory\+Hook\+::overflow\+\_\+heap\+\_\+size (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}

This callback method is called whenever the total allocated heap size exceeds \+\_\+max\+\_\+heap\+\_\+size. It\textquotesingle{}s mainly intended for reporting memory leaks, on the assumption that once we cross some specified threshold, we\textquotesingle{}re just leaking memory.

The implementation for this method is in \doxylink{classMemoryUsage}{Memory\+Usage}. 

Reimplemented in \mbox{\hyperlink{classMemoryUsage_a0c80c7ac4239923e7625aac4088714ef}{Memory\+Usage}}.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
dtool/src/dtoolbase/\mbox{\hyperlink{memoryHook_8h}{memory\+Hook.\+h}}\item 
dtool/src/dtoolbase/\mbox{\hyperlink{memoryHook_8cxx}{memory\+Hook.\+cxx}}\end{DoxyCompactItemize}
