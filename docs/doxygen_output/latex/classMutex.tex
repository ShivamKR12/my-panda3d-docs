\doxysection{Mutex Class Reference}
\hypertarget{classMutex}{}\label{classMutex}\index{Mutex@{Mutex}}


{\ttfamily \#include $<$pmutex.\+h$>$}

Inheritance diagram for Mutex\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classMutex}
\end{center}
\end{figure}
\doxysubsubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classMutex_a2215ee87416da20b80f615e0023f31be}\label{classMutex_a2215ee87416da20b80f615e0023f31be} 
INLINE {\bfseries Mutex} (const char \texorpdfstring{$\ast$}{*}name)
\item 
\Hypertarget{classMutex_a5bfda287ff92f35ec5fec55c91c83da3}\label{classMutex_a5bfda287ff92f35ec5fec55c91c83da3} 
{\bfseries Mutex} (const \mbox{\hyperlink{classMutex}{Mutex}} \&copy)=delete
\item 
\Hypertarget{classMutex_a54b5eeb2b7dc342a04d0512010f7fa43}\label{classMutex_a54b5eeb2b7dc342a04d0512010f7fa43} 
void {\bfseries operator=} (const \mbox{\hyperlink{classMutex}{Mutex}} \&copy)=delete
\item 
\Hypertarget{classMutex_ae59f52410490a8894246eee98e7bb303}\label{classMutex_ae59f52410490a8894246eee98e7bb303} 
{\bfseries EXTENSION} (bool acquire(bool blocking=true) const)
\item 
\Hypertarget{classMutex_a4a676e65c8e964e23a8eaf3dd04471be}\label{classMutex_a4a676e65c8e964e23a8eaf3dd04471be} 
{\bfseries PY\+\_\+\+EXTENSION} (bool \+\_\+\+\_\+enter\+\_\+\+\_\+())
\item 
\Hypertarget{classMutex_aa98b5d1c96ce9cb92f484880fb471d17}\label{classMutex_aa98b5d1c96ce9cb92f484880fb471d17} 
{\bfseries PY\+\_\+\+EXTENSION} (void \+\_\+\+\_\+exit\+\_\+\+\_\+(Py\+Object \texorpdfstring{$\ast$}{*}, Py\+Object \texorpdfstring{$\ast$}{*}, Py\+Object \texorpdfstring{$\ast$}{*}))
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions inherited from \mbox{\hyperlink{classMutexDirect}{Mutex\+Direct}}}
\begin{DoxyCompactItemize}
\item 
INLINE void {\bfseries lock} ()
\item 
INLINE bool {\bfseries try\+\_\+lock} ()
\item 
INLINE void {\bfseries unlock} ()
\item 
BLOCKING INLINE bool {\bfseries try\+\_\+acquire} () const
\item 
INLINE void {\bfseries release} () const
\item 
INLINE bool {\bfseries debug\+\_\+is\+\_\+locked} () const
\item 
INLINE void {\bfseries set\+\_\+name} (const std\+::string \&name)
\item 
INLINE void {\bfseries clear\+\_\+name} ()
\item 
INLINE bool {\bfseries has\+\_\+name} () const
\item 
INLINE std\+::string {\bfseries get\+\_\+name} () const
\item 
void \mbox{\hyperlink{classMutexDirect_a6c9d769b4cab10ff598180f2c34a282c}{output}} (std\+::ostream \&out) const
\end{DoxyCompactItemize}
\doxysubsubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classMutex_a6a59bb650a902b6faacc0a00f4a5cd03}\label{classMutex_a6a59bb650a902b6faacc0a00f4a5cd03} 
PUBLISHED \+: INLINE explicit \mbox{\hyperlink{classMutex}{Mutex}}(const std\+::string \&name)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes inherited from \mbox{\hyperlink{classMutexDirect}{Mutex\+Direct}}}
\begin{DoxyCompactItemize}
\item 
PUBLISHED \+: BLOCKING INLINE void acquire() const
\end{DoxyCompactItemize}
\doxysubsubsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
\Hypertarget{classMutex_a0e0e6cf6056cb6c951e2c9e17594037d}\label{classMutex_a0e0e6cf6056cb6c951e2c9e17594037d} 
static \mbox{\hyperlink{classMutex}{Mutex}} {\bfseries \+\_\+notify\+\_\+mutex}
\end{DoxyCompactItemize}
\doxysubsubsection*{Additional Inherited Members}
\doxysubsection*{Protected Member Functions inherited from \mbox{\hyperlink{classMutexDirect}{Mutex\+Direct}}}
\begin{DoxyCompactItemize}
\item 
{\bfseries Mutex\+Direct} (const \mbox{\hyperlink{classMutexDirect}{Mutex\+Direct}} \&copy)=delete
\item 
void {\bfseries operator=} (const \mbox{\hyperlink{classMutexDirect}{Mutex\+Direct}} \&copy)=delete
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
A standard mutex, or mutual exclusion lock. Only one thread can hold ("{}lock"{}) a mutex at any given time; other threads trying to grab the mutex will block until the holding thread releases it.

The standard mutex is not reentrant\+: a thread may not attempt to lock it twice. Although this may happen to work on some platforms (e.\+g. Win32), it will not work on all platforms; on some platforms, a thread can deadlock itself by attempting to lock the same mutex twice. If your code requires a reentrant mutex, use the \doxylink{classReMutex}{Re\+Mutex} class instead.

This class inherits its implementation either from Mutex\+Debug or \doxylink{classMutexDirect}{Mutex\+Direct}, depending on the definition of DEBUG\+\_\+\+THREADS. 

The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
panda/src/pipeline/\mbox{\hyperlink{pmutex_8h}{pmutex.\+h}}\item 
panda/src/pipeline/\mbox{\hyperlink{pmutex_8cxx}{pmutex.\+cxx}}\end{DoxyCompactItemize}
