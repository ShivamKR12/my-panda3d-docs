<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D C++ Architecture: MemoryHook Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Panda3D C++ Architecture
   </div>
   <div id="projectbrief">API reference for Panda3D&#39;s C++ codebase.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classMemoryHook-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">MemoryHook Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="memoryHook_8h_source.html">memoryHook.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MemoryHook:</div>
<div class="dyncontent">
<div class="center"><img src="classMemoryHook__inherit__graph.png" border="0" usemap="#aMemoryHook_inherit__map" alt="Inheritance graph"/></div>
<map name="aMemoryHook_inherit__map" id="aMemoryHook_inherit__map">
<area shape="rect" title=" " alt="" coords="10,5,132,30"/>
<area shape="rect" href="classMemoryUsage.html" title=" " alt="" coords="5,78,137,103"/>
<area shape="poly" title=" " alt="" coords="74,46,74,78,68,78,68,46"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for MemoryHook:</div>
<div class="dyncontent">
<div class="center"><img src="classMemoryHook__coll__graph.png" border="0" usemap="#aMemoryHook_coll__map" alt="Collaboration graph"/></div>
<map name="aMemoryHook_coll__map" id="aMemoryHook_coll__map">
<area shape="rect" title=" " alt="" coords="40,1394605,162,1394630"/>
<area shape="rect" href="structpatomic.html" title=" " alt="" coords="5,5,197,30"/>
<area shape="poly" title=" " alt="" coords="104,45,104,1394605,98,1394605,98,45"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:af98a6c8f454aa1a4aa7f8cf7b9cc5203"><td class="memItemLeft" align="right" valign="top"><a id="af98a6c8f454aa1a4aa7f8cf7b9cc5203" name="af98a6c8f454aa1a4aa7f8cf7b9cc5203"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MemoryHook</b> (const <a class="el" href="classMemoryHook.html">MemoryHook</a> &amp;copy)</td></tr>
<tr class="separator:af98a6c8f454aa1a4aa7f8cf7b9cc5203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7555492ddf2d21b4e4257b4492532ed7"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a7555492ddf2d21b4e4257b4492532ed7">heap_alloc_single</a> (size_t size)</td></tr>
<tr class="separator:a7555492ddf2d21b4e4257b4492532ed7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898d872432e052aaa04113be37b53fa5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a898d872432e052aaa04113be37b53fa5">heap_free_single</a> (void *ptr)</td></tr>
<tr class="separator:a898d872432e052aaa04113be37b53fa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48f518b2d475945b0e0dc4f256c68626"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a48f518b2d475945b0e0dc4f256c68626">heap_alloc_array</a> (size_t size)</td></tr>
<tr class="separator:a48f518b2d475945b0e0dc4f256c68626"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6dd724d878249f8902bab6d51e96b72"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#ab6dd724d878249f8902bab6d51e96b72">heap_realloc_array</a> (void *ptr, size_t size)</td></tr>
<tr class="separator:ab6dd724d878249f8902bab6d51e96b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c1598f606ff745dc1cb1e2c593ebd47"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a6c1598f606ff745dc1cb1e2c593ebd47">heap_free_array</a> (void *ptr)</td></tr>
<tr class="separator:a6c1598f606ff745dc1cb1e2c593ebd47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0fcacba846ad0f1ce456fa01e10c6c"><td class="memItemLeft" align="right" valign="top"><a id="a5d0fcacba846ad0f1ce456fa01e10c6c" name="a5d0fcacba846ad0f1ce456fa01e10c6c"></a>
INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>inc_heap</b> (size_t size)</td></tr>
<tr class="separator:a5d0fcacba846ad0f1ce456fa01e10c6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf74987d0734fc62aa1316072030c806"><td class="memItemLeft" align="right" valign="top"><a id="abf74987d0734fc62aa1316072030c806" name="abf74987d0734fc62aa1316072030c806"></a>
INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>dec_heap</b> (size_t size)</td></tr>
<tr class="separator:abf74987d0734fc62aa1316072030c806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb42686df80c3f38bbaa59232d71f29"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#aacb42686df80c3f38bbaa59232d71f29">heap_trim</a> (size_t pad)</td></tr>
<tr class="separator:aacb42686df80c3f38bbaa59232d71f29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf6209c089890e81f127b4f1f429cb8"><td class="memItemLeft" align="right" valign="top">virtual void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a1bf6209c089890e81f127b4f1f429cb8">mmap_alloc</a> (size_t size, bool allow_exec)</td></tr>
<tr class="separator:a1bf6209c089890e81f127b4f1f429cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db3083e6f6274e9e94b4171f36f7163"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a1db3083e6f6274e9e94b4171f36f7163">mmap_free</a> (void *ptr, size_t size)</td></tr>
<tr class="separator:a1db3083e6f6274e9e94b4171f36f7163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2aa42e398078bf323d616bba1484ebe"><td class="memItemLeft" align="right" valign="top"><a id="ad2aa42e398078bf323d616bba1484ebe" name="ad2aa42e398078bf323d616bba1484ebe"></a>
INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_page_size</b> () const</td></tr>
<tr class="separator:ad2aa42e398078bf323d616bba1484ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947b6cea69d162e6c3b892af312f50a3"><td class="memItemLeft" align="right" valign="top"><a id="a947b6cea69d162e6c3b892af312f50a3" name="a947b6cea69d162e6c3b892af312f50a3"></a>
INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><b>round_up_to_page_size</b> (size_t size) const</td></tr>
<tr class="separator:a947b6cea69d162e6c3b892af312f50a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3d40238b568141a6fedfc8f58f9202"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a7d3d40238b568141a6fedfc8f58f9202">mark_pointer</a> (void *ptr, size_t orig_size, <a class="el" href="classReferenceCount.html">ReferenceCount</a> *ref_ptr)</td></tr>
<tr class="separator:a7d3d40238b568141a6fedfc8f58f9202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca590278137439b1f3b12a5ac896bf9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a3ca590278137439b1f3b12a5ac896bf9">alloc_fail</a> (size_t attempted_size)</td></tr>
<tr class="separator:a3ca590278137439b1f3b12a5ac896bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae0e773749c197162f7166bec7e1d0baa"><td class="memItemLeft" align="right" valign="top"><a id="ae0e773749c197162f7166bec7e1d0baa" name="ae0e773749c197162f7166bec7e1d0baa"></a>
static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_memory_alignment</b> ()</td></tr>
<tr class="separator:ae0e773749c197162f7166bec7e1d0baa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7319c9d2911cc0836ad5eb7fa596e9d"><td class="memItemLeft" align="right" valign="top"><a id="aa7319c9d2911cc0836ad5eb7fa596e9d" name="aa7319c9d2911cc0836ad5eb7fa596e9d"></a>
static INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_ptr_size</b> (void *ptr)</td></tr>
<tr class="separator:aa7319c9d2911cc0836ad5eb7fa596e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-methods" name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a384863305e12229f4f5e9d292c2e8146"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a384863305e12229f4f5e9d292c2e8146">overflow_heap_size</a> ()</td></tr>
<tr class="separator:a384863305e12229f4f5e9d292c2e8146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fbd1025459bf0cfd59cbce39e506d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMemoryHook.html#a50fbd1025459bf0cfd59cbce39e506d9">determine_page_size</a> () const</td></tr>
<tr class="separator:a50fbd1025459bf0cfd59cbce39e506d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pro-attribs" name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a9785a140537d3d450c5d52a650617387"><td class="memItemLeft" align="right" valign="top"><a id="a9785a140537d3d450c5d52a650617387" name="a9785a140537d3d450c5d52a650617387"></a>
<a class="el" href="structpatomic.html">patomic</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_total_heap_single_size</b> { 0u }</td></tr>
<tr class="separator:a9785a140537d3d450c5d52a650617387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1229495e50ba850768b259b14a151f35"><td class="memItemLeft" align="right" valign="top"><a id="a1229495e50ba850768b259b14a151f35" name="a1229495e50ba850768b259b14a151f35"></a>
<a class="el" href="structpatomic.html">patomic</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_total_heap_array_size</b> { 0u }</td></tr>
<tr class="separator:a1229495e50ba850768b259b14a151f35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad489330b5e7ce65c580a2ff4da5da1f7"><td class="memItemLeft" align="right" valign="top"><a id="ad489330b5e7ce65c580a2ff4da5da1f7" name="ad489330b5e7ce65c580a2ff4da5da1f7"></a>
<a class="el" href="structpatomic.html">patomic</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_requested_heap_size</b> { 0u }</td></tr>
<tr class="separator:ad489330b5e7ce65c580a2ff4da5da1f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37be7726f3804ea39dc686ca7da58125"><td class="memItemLeft" align="right" valign="top"><a id="a37be7726f3804ea39dc686ca7da58125" name="a37be7726f3804ea39dc686ca7da58125"></a>
<a class="el" href="structpatomic.html">patomic</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>_total_mmap_size</b> { 0u }</td></tr>
<tr class="separator:a37be7726f3804ea39dc686ca7da58125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9158e5b94c66870a049451dc8459c02e"><td class="memItemLeft" align="right" valign="top"><a id="a9158e5b94c66870a049451dc8459c02e" name="a9158e5b94c66870a049451dc8459c02e"></a>
size_t&#160;</td><td class="memItemRight" valign="bottom"><b>_max_heap_size</b> = ~(size_t)0</td></tr>
<tr class="separator:a9158e5b94c66870a049451dc8459c02e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides a wrapper around the various possible malloc schemes Panda might employ. It also exists to allow the <a class="el" href="classMemoryUsage.html">MemoryUsage</a> class in Panda to insert callback hooks to track the size of allocated pointers.</p>
<p>The PANDA_MALLOC_* and PANDA_FREE_* macros are defined to vector through through this class (except in production builds) to facilitate that. Every memory allocation call in Panda should therefore use these macros instead of direct calls to malloc or free. (C++ new and delete operators may be employed for classes which inherit from <a class="el" href="classMemoryBase.html">MemoryBase</a>; otherwise, use the PANDA_MALLOC macros.) </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a3ca590278137439b1f3b12a5ac896bf9" name="a3ca590278137439b1f3b12a5ac896bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca590278137439b1f3b12a5ac896bf9">&#9670;&#160;</a></span>alloc_fail()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryHook::alloc_fail </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attempted_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This callback method is called whenever a low-level call to call_malloc() has returned NULL, indicating failure.</p>
<p>Since this method is called very low-level, and may be in the middle of any number of critical sections, it will be difficult for this callback initiate any emergency high-level operation to make more memory available. However, this module is set up to assume that that's what this method does, and will make another alloc attempt after it returns. Probably the only sensible thing this method can do, however, is just to display a message and abort. </p>

</div>
</div>
<a id="a50fbd1025459bf0cfd59cbce39e506d9" name="a50fbd1025459bf0cfd59cbce39e506d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fbd1025459bf0cfd59cbce39e506d9">&#9670;&#160;</a></span>determine_page_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryHook::determine_page_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Asks the operating system for the page size. </p>

</div>
</div>
<a id="a48f518b2d475945b0e0dc4f256c68626" name="a48f518b2d475945b0e0dc4f256c68626"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48f518b2d475945b0e0dc4f256c68626">&#9670;&#160;</a></span>heap_alloc_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * MemoryHook::heap_alloc_array </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a block of memory from the heap, similar to malloc(). This will never return NULL; it will abort instead if memory is not available.</p>
<p>This particular function should be used to allocate memory for an array of objects, as opposed to a single object. The only difference is in the bookkeeping. </p>

<p>Reimplemented in <a class="el" href="classMemoryUsage.html#ac19a2d0adf46d3f4bc14184c62ab19af">MemoryUsage</a>.</p>

</div>
</div>
<a id="a7555492ddf2d21b4e4257b4492532ed7" name="a7555492ddf2d21b4e4257b4492532ed7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7555492ddf2d21b4e4257b4492532ed7">&#9670;&#160;</a></span>heap_alloc_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * MemoryHook::heap_alloc_single </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a block of memory from the heap, similar to malloc(). This will never return NULL; it will abort instead if memory is not available.</p>
<p>This particular function should be used to allocate memory for a single object, as opposed to an array. The only difference is in the bookkeeping. </p>

<p>Reimplemented in <a class="el" href="classMemoryUsage.html#a83b32436dd9cee3d5b59dec22a203703">MemoryUsage</a>.</p>

</div>
</div>
<a id="a6c1598f606ff745dc1cb1e2c593ebd47" name="a6c1598f606ff745dc1cb1e2c593ebd47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c1598f606ff745dc1cb1e2c593ebd47">&#9670;&#160;</a></span>heap_free_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryHook::heap_free_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases a block of memory previously allocated via heap_alloc_array. </p>

<p>Reimplemented in <a class="el" href="classMemoryUsage.html#a7dda729b0c75618360ea928538bba294">MemoryUsage</a>.</p>

</div>
</div>
<a id="a898d872432e052aaa04113be37b53fa5" name="a898d872432e052aaa04113be37b53fa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898d872432e052aaa04113be37b53fa5">&#9670;&#160;</a></span>heap_free_single()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryHook::heap_free_single </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Releases a block of memory previously allocated via heap_alloc_single. </p>

<p>Reimplemented in <a class="el" href="classMemoryUsage.html#a5fd057965df5b3b88181dba761c66ba0">MemoryUsage</a>.</p>

</div>
</div>
<a id="ab6dd724d878249f8902bab6d51e96b72" name="ab6dd724d878249f8902bab6d51e96b72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6dd724d878249f8902bab6d51e96b72">&#9670;&#160;</a></span>heap_realloc_array()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * MemoryHook::heap_realloc_array </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Resizes a block of memory previously returned from heap_alloc_array. </p>

<p>Reimplemented in <a class="el" href="classMemoryUsage.html#a76cb17df1b567caa751a716529c1d7e2">MemoryUsage</a>.</p>

</div>
</div>
<a id="aacb42686df80c3f38bbaa59232d71f29" name="aacb42686df80c3f38bbaa59232d71f29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacb42686df80c3f38bbaa59232d71f29">&#9670;&#160;</a></span>heap_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MemoryHook::heap_trim </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pad</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to release memory back to the system, if possible. The pad argument is the minimum amount of unused memory to keep in the heap (against future allocations). Any memory above that may be released to the system, reducing the memory size of this process. There is no guarantee that any memory may be released.</p>
<p>Returns true if any memory was actually released, false otherwise. </p>

</div>
</div>
<a id="a7d3d40238b568141a6fedfc8f58f9202" name="a7d3d40238b568141a6fedfc8f58f9202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3d40238b568141a6fedfc8f58f9202">&#9670;&#160;</a></span>mark_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryHook::mark_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>orig_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classReferenceCount.html">ReferenceCount</a> *&#160;</td>
          <td class="paramname"><em>ref_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This special method exists only to provide a callback hook into <a class="el" href="classMemoryUsage.html">MemoryUsage</a>. It indicates that the indicated pointer, allocated from somewhere other than a call to heap_alloc(), now contains a pointer to the indicated <a class="el" href="classReferenceCount.html">ReferenceCount</a> object. If orig_size is 0, it indicates that the <a class="el" href="classReferenceCount.html">ReferenceCount</a> object has been destroyed. </p>

<p>Reimplemented in <a class="el" href="classMemoryUsage.html#ad631b7a26b1eb7476ce9999e687addf8">MemoryUsage</a>.</p>

</div>
</div>
<a id="a1bf6209c089890e81f127b4f1f429cb8" name="a1bf6209c089890e81f127b4f1f429cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf6209c089890e81f127b4f1f429cb8">&#9670;&#160;</a></span>mmap_alloc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void * MemoryHook::mmap_alloc </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_exec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Allocates a raw page or pages of memory directly from the OS. This will be in a different address space from the memory allocated by heap_alloc(), and so it won't contribute to fragmentation of that memory.</p>
<p>The allocation size must be an integer multiple of the page size. Use round_to_page_size() if there is any doubt.</p>
<p>If allow_exec is true, the memory will be flagged so that it is legal to execute code that has been written to this memory. </p>

</div>
</div>
<a id="a1db3083e6f6274e9e94b4171f36f7163" name="a1db3083e6f6274e9e94b4171f36f7163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db3083e6f6274e9e94b4171f36f7163">&#9670;&#160;</a></span>mmap_free()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryHook::mmap_free </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Frees a block of memory previously allocated via <a class="el" href="classMemoryHook.html#a1bf6209c089890e81f127b4f1f429cb8">mmap_alloc()</a>. You must know how large the block was. </p>

</div>
</div>
<a id="a384863305e12229f4f5e9d292c2e8146" name="a384863305e12229f4f5e9d292c2e8146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384863305e12229f4f5e9d292c2e8146">&#9670;&#160;</a></span>overflow_heap_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void MemoryHook::overflow_heap_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This callback method is called whenever the total allocated heap size exceeds _max_heap_size. It's mainly intended for reporting memory leaks, on the assumption that once we cross some specified threshold, we're just leaking memory.</p>
<p>The implementation for this method is in <a class="el" href="classMemoryUsage.html">MemoryUsage</a>. </p>

<p>Reimplemented in <a class="el" href="classMemoryUsage.html#a0c80c7ac4239923e7625aac4088714ef">MemoryUsage</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>dtool/src/dtoolbase/<a class="el" href="memoryHook_8h_source.html">memoryHook.h</a></li>
<li>dtool/src/dtoolbase/<a class="el" href="memoryHook_8cxx_source.html">memoryHook.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
