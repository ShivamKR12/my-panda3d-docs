<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D C++ Architecture: panda/src/glstuff/glGraphicsStateGuardian_src.cxx File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Panda3D C++ Architecture
   </div>
   <div id="projectbrief">API reference for Panda3D&#39;s C++ codebase.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_55f581b38302390417cc7352018b90c5.html">panda</a></li><li class="navelem"><a class="el" href="dir_e9ddf517b326a08d2e0c745033a8a7d4.html">src</a></li><li class="navelem"><a class="el" href="dir_05599d421f2016b13d7a6fdd16b6e03d.html">glstuff</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">glGraphicsStateGuardian_src.cxx File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="config__putil_8h_source.html">config_putil.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="displayRegion_8h_source.html">displayRegion.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="renderBuffer_8h_source.html">renderBuffer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geom_8h_source.html">geom.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomVertexData_8h_source.html">geomVertexData.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomTriangles_8h_source.html">geomTriangles.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomTristrips_8h_source.html">geomTristrips.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomTrifans_8h_source.html">geomTrifans.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomLines_8h_source.html">geomLines.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomLinestrips_8h_source.html">geomLinestrips.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomPatches_8h_source.html">geomPatches.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomPoints_8h_source.html">geomPoints.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="geomVertexReader_8h_source.html">geomVertexReader.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="graphicsWindow_8h_source.html">graphicsWindow.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lens_8h_source.html">lens.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="perspectiveLens_8h_source.html">perspectiveLens.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="directionalLight_8h_source.html">directionalLight.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pointLight_8h_source.html">pointLight.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="spotlight_8h_source.html">spotlight.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="planeNode_8h_source.html">planeNode.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fog_8h_source.html">fog.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="clockObject_8h_source.html">clockObject.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="string__utils_8h_source.html">string_utils.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="nodePath_8h_source.html">nodePath.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="dcast_8h_source.html">dcast.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pvector_8h_source.html">pvector.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="vector__string_8h_source.html">vector_string.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pnmImage_8h_source.html">pnmImage.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="config__gobj_8h_source.html">config_gobj.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lightMutexHolder_8h_source.html">lightMutexHolder.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="indirectLess_8h_source.html">indirectLess.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="pStatTimer_8h_source.html">pStatTimer.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="load__prc__file_8h_source.html">load_prc_file.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="bamCache_8h_source.html">bamCache.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="bamCacheRecord_8h_source.html">bamCacheRecord.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="alphaTestAttrib_8h_source.html">alphaTestAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="clipPlaneAttrib_8h_source.html">clipPlaneAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cullFaceAttrib_8h_source.html">cullFaceAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="depthBiasAttrib_8h_source.html">depthBiasAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="depthOffsetAttrib_8h_source.html">depthOffsetAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="depthWriteAttrib_8h_source.html">depthWriteAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="fogAttrib_8h_source.html">fogAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="lightAttrib_8h_source.html">lightAttrib.h</a>&quot;</code><br />
<code>#include &quot;logicOpAttrib.h&quot;</code><br />
<code>#include &quot;<a class="el" href="materialAttrib_8h_source.html">materialAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rescaleNormalAttrib_8h_source.html">rescaleNormalAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="scissorAttrib_8h_source.html">scissorAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="shadeModelAttrib_8h_source.html">shadeModelAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="stencilAttrib_8h_source.html">stencilAttrib.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="graphicsEngine_8h_source.html">graphicsEngine.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="shaderGenerator_8h_source.html">shaderGenerator.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="samplerState_8h_source.html">samplerState.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="displayInformation_8h_source.html">displayInformation.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="completionCounter_8h_source.html">completionCounter.h</a>&quot;</code><br />
<code>#include &lt;algorithm&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="glGraphicsStateGuardian__src_8cxx__dep__incl.png" border="0" usemap="#apanda_2src_2glstuff_2glGraphicsStateGuardian__src_8cxxdep" alt=""/></div>
<map name="apanda_2src_2glstuff_2glGraphicsStateGuardian__src_8cxxdep" id="apanda_2src_2glstuff_2glGraphicsStateGuardian__src_8cxxdep">
<area shape="rect" title=" " alt="" coords="235,5,537,771176"/>
<area shape="rect" href="glstuff__src_8cxx.html" title=" " alt="" coords="250,771224,522,771262"/>
<area shape="poly" title=" " alt="" coords="389,771191,389,771223,383,771223,383,771191"/>
<area shape="rect" href="gles2gsg_8cxx.html" title=" " alt="" coords="5,771310,207,771349"/>
<area shape="poly" title=" " alt="" coords="310,771270,169,771312,167,771307,308,771265"/>
<area shape="rect" href="glesgsg_8cxx.html" title=" " alt="" coords="230,771317,542,771342"/>
<area shape="poly" title=" " alt="" coords="389,771278,389,771317,383,771317,383,771278"/>
<area shape="rect" href="glgsg_8cxx.html" title=" " alt="" coords="566,771317,838,771342"/>
<area shape="poly" title=" " alt="" coords="471,771264,659,771314,658,771319,470,771269"/>
</map>
</div>
</div>
<p><a href="glGraphicsStateGuardian__src_8cxx_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a0e133fd0b91dcbba9c5510194f990d84"><td class="memItemLeft" align="right" valign="top"><a id="a0e133fd0b91dcbba9c5510194f990d84" name="a0e133fd0b91dcbba9c5510194f990d84"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>PANDA_TO_GL_COMPAREFUNC</b>(PANDACMPFUNC)&#160;&#160;&#160;(PANDACMPFUNC-1 +0x200)</td></tr>
<tr class="separator:a0e133fd0b91dcbba9c5510194f990d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a24d1dd8002afed2232232a227822c16f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glGraphicsStateGuardian__src_8cxx.html#a24d1dd8002afed2232232a227822c16f">CLP</a> (<a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a>)</td></tr>
<tr class="separator:a24d1dd8002afed2232232a227822c16f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25fc983f3b6c4814356cfb81598ae7ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glGraphicsStateGuardian__src_8cxx.html#a25fc983f3b6c4814356cfb81598ae7ed">CPT</a> (<a class="el" href="classTransformState.html">TransformState</a>) CLP(<a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a>)</td></tr>
<tr class="separator:a25fc983f3b6c4814356cfb81598ae7ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf9e5a8358d76c086f2ca71425e94008"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glGraphicsStateGuardian__src_8cxx.html#acf9e5a8358d76c086f2ca71425e94008">CLP</a> (<a class="el" href="classBufferContext.html">BufferContext</a>) *CLP(<a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a>)</td></tr>
<tr class="separator:acf9e5a8358d76c086f2ca71425e94008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aea0bf7f25e37b8a3475e745d87b6e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glGraphicsStateGuardian__src_8cxx.html#a21aea0bf7f25e37b8a3475e745d87b6e">PT</a> (<a class="el" href="classOcclusionQueryContext.html">OcclusionQueryContext</a>) CLP(<a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a>)</td></tr>
<tr class="separator:a21aea0bf7f25e37b8a3475e745d87b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c051e9395293f1d0b23f5b002e4157"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="glGraphicsStateGuardian__src_8cxx.html#ad8c051e9395293f1d0b23f5b002e4157">PT</a> (<a class="el" href="classGeomMunger.html">GeomMunger</a>) CLP(<a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a>)</td></tr>
<tr class="separator:ad8c051e9395293f1d0b23f5b002e4157"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>PANDA 3D SOFTWARE Copyright (c) Carnegie Mellon University. All rights reserved.</p>
<p>All use of this software is subject to the terms of the revised BSD license. You should have received a copy of this license along with this source code in a file named "LICENSE."</p>
<dl class="section author"><dt>Author</dt><dd>drose </dd></dl>
<dl class="section date"><dt>Date</dt><dd>1999-02-02 </dd></dl>
<dl class="section author"><dt>Author</dt><dd>fperazzi, PandaSE </dd></dl>
<dl class="section date"><dt>Date</dt><dd>2010-05-05 get_supports_cg_profile) </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acf9e5a8358d76c086f2ca71425e94008" name="acf9e5a8358d76c086f2ca71425e94008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf9e5a8358d76c086f2ca71425e94008">&#9670;&#160;</a></span>CLP() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CLP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBufferContext.html">BufferContext</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Binds the given shader buffer to the given binding slot. </p>

</div>
</div>
<a id="a24d1dd8002afed2232232a227822c16f" name="a24d1dd8002afed2232232a227822c16f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24d1dd8002afed2232232a227822c16f">&#9670;&#160;</a></span>CLP() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void CLP </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is called by the GL if an error occurs, if gl_debug has been enabled (and the driver supports the GL_ARB_debug_output extension).</p>
<p>Resets all internal state as if the gsg were newly created.</p>
<p>Force the graphics card to finish drawing before returning. !!!!!HACK WARNING!!!! glfinish does not actually wait for the graphics card to finish drawing only for draw calls to finish. Thus flip may not happene immediately. Instead we read a single pixel from the framebuffer. This forces the graphics card to finish drawing the frame before returning.</p>
<p>Clears the framebuffer within the current <a class="el" href="classDisplayRegion.html">DisplayRegion</a>, according to the flags indicated by the given <a class="el" href="classDrawableRegion.html">DrawableRegion</a> object.</p>
<p>This does not set the <a class="el" href="classDisplayRegion.html">DisplayRegion</a> first. You should call prepare_display_region() to specify the region you wish the clear operation to apply to.</p>
<p>Prepare a display region for rendering (set up scissor region and viewport)</p>
<p>Resets any non-standard graphics state that might give a callback apoplexy. Some drivers require that the graphics state be restored to neutral before performing certain operations. In OpenGL, for instance, this closes any open vertex buffers.</p>
<p>Makes the current lens (whichever lens was most recently specified with set_scene()) active, so that it will transform future rendered geometry. Normally this is only called from the draw process, and usually it is called by set_scene().</p>
<p>The return value is true if the lens is acceptable, false if it is not.</p>
<p>Called before each frame is rendered, to allow the GSG a chance to do any internal cleanup before beginning the frame.</p>
<p>The return value is true if successful (in which case the frame will be drawn and end_frame() will be called later), or false if unsuccessful (in which case nothing will be drawn and end_frame() will not be called).</p>
<p>Called between begin_frame() and end_frame() to mark the beginning of drawing commands for a "scene" (usually a particular <a class="el" href="classDisplayRegion.html">DisplayRegion</a>) within a frame. All 3-D drawing commands, except the clear operation, must be enclosed within begin_scene() .. end_scene().</p>
<p>The return value is true if successful (in which case the scene will be drawn and end_scene() will be called later), or false if unsuccessful (in which case nothing will be drawn and end_scene() will not be called).</p>
<p>Called between begin_frame() and end_frame() to mark the end of drawing commands for a "scene" (usually a particular <a class="el" href="classDisplayRegion.html">DisplayRegion</a>) within a frame. All 3-D drawing commands, except the clear operation, must be enclosed within begin_scene() .. end_scene().</p>
<p>Called after each frame is rendered, to allow the GSG a chance to do any internal cleanup after rendering the frame, and before the window flips.</p>
<p>Gets the timer query results for the given frame and sends them to the PStats server.</p>
<p>Called before a sequence of draw_primitive() functions are called, this should prepare the vertex data for rendering. It returns true if the vertices are ok, false to abort this group of primitives.</p>
<p>Ensures the vertex and array buffers are no longer bound. Some graphics drivers crash if these are left bound indiscriminantly.</p>
<p>Updates the vertex format used by the shader. This is still an experimental feature.</p>
<p>Draws a series of disconnected triangles.</p>
<p>Draws a series of disconnected triangles with adjacency information.</p>
<p>Draws a series of triangle strips.</p>
<p>Draws a series of triangle strips with adjacency information.</p>
<p>Draws a series of triangle fans.</p>
<p>Draws a series of "patches", which can only be processed by a tessellation shader.</p>
<p>Draws a series of disconnected line segments.</p>
<p>Draws a series of disconnected line segments with adjacency information.</p>
<p>Draws a series of line strips.</p>
<p>Draws a series of line strips with adjacency information.</p>
<p>Draws a series of disconnected points.</p>
<p>Called after a sequence of draw_primitive() functions are called, this should do whatever cleanup is appropriate.</p>
<p>Issues the given memory barriers, and clears the list of textures marked as incoherent for the given bits.</p>
<p>Creates whatever structures the GSG requires to represent the texture internally, and returns a newly-allocated <a class="el" href="classTextureContext.html">TextureContext</a> object with this data. It is the responsibility of the calling function to later call release_texture() with this same pointer (which will also delete the pointer).</p>
<p>This function should not be called directly to prepare a texture. Instead, call Texture::prepare().</p>
<p>Ensures that the current <a class="el" href="classTexture.html">Texture</a> data is refreshed onto the GSG. This means updating the texture properties and/or re-uploading the texture image, if necessary. This should only be called within the draw thread.</p>
<p>If force is true, this function will not return until the texture has been fully uploaded. If force is false, the function may choose to upload a simple version of the texture instead, if the texture is not fully resident (and if get_incomplete_render() is true).</p>
<p>Frees the GL resources previously allocated for the texture. This function should never be called directly; instead, call <a class="el" href="classTexture.html#aa2b01d0895bb0772c4831f01d2c954ea">Texture::release()</a> (or simply let the <a class="el" href="classTexture.html">Texture</a> destruct).</p>
<p>Frees the GL resources previously allocated for the textures. This function should never be called directly; instead, call <a class="el" href="classTexture.html#aa2b01d0895bb0772c4831f01d2c954ea">Texture::release()</a> (or simply let the <a class="el" href="classTexture.html">Texture</a> destruct).</p>
<p>This method should only be called by the <a class="el" href="classGraphicsEngine.html">GraphicsEngine</a>. Do not call it directly; call GraphicsEngine::extract_texture_data() instead.</p>
<p>This method will be called in the draw thread to download the texture memory's image into its ram_image value. It returns true on success, false otherwise.</p>
<p>Creates whatever structures the GSG requires to represent the sampler state internally, and returns a newly-allocated <a class="el" href="classSamplerContext.html">SamplerContext</a> object with this data. It is the responsibility of the calling function to later call release_sampler() with this same pointer (which will also delete the pointer).</p>
<p>This function should not be called directly to prepare a sampler object. Instead, call SamplerState::prepare().</p>
<p>Frees the GL resources previously allocated for the sampler. This function should never be called directly; instead, call SamplerState::release().</p>
<p>Creates a new retained-mode representation of the given geom, and returns a newly-allocated <a class="el" href="classGeomContext.html">GeomContext</a> pointer to reference it. It is the responsibility of the calling function to later call release_geom() with this same pointer (which will also delete the pointer).</p>
<p>This function should not be called directly to prepare a geom. Instead, call <a class="el" href="classGeom.html#a0bf675037d2a13dfefa176d7c2be0486">Geom::prepare()</a>.</p>
<p>Frees the GL resources previously allocated for the geom. This function should never be called directly; instead, call <a class="el" href="classGeom.html#a4a2094ebeac0db8b75c22a6ce1c53d3f">Geom::release()</a> (or simply let the <a class="el" href="classGeom.html">Geom</a> destruct).</p>
<p>This is intended to be called only from the GLGeomContext destructor. It saves the indicated display list index in the list to be deleted at the end of the frame.</p>
<p>Creates a new buffer for client access. It is bound when this returns. If persistent mapping is possible, mapped_ptr will be filled in with a pointer to the mapped data.</p>
<p>Called when the given buffer, as returned by bind_new_client_buffer, is no longer needed.</p>
<p>Creates a new retained-mode representation of the given data, and returns a newly-allocated <a class="el" href="classVertexBufferContext.html">VertexBufferContext</a> pointer to reference it. It is the responsibility of the calling function to later call release_vertex_buffer() with this same pointer (which will also delete the pointer).</p>
<p>This function should not be called directly to prepare a buffer. Instead, call <a class="el" href="classGeom.html#a0bf675037d2a13dfefa176d7c2be0486">Geom::prepare()</a>.</p>
<p>Makes sure that the data in the vertex buffer is up-to-date. This may bind it to the GL_ARRAY_BUFFER binding point if necessary.</p>
<p>Frees the GL resources previously allocated for the data. This function should never be called directly; instead, call Data::release() (or simply let the Data destruct).</p>
<p>Internal function to bind a buffer object for the indicated data array, if appropriate, or to unbind a buffer object if it should be rendered from client memory.</p>
<p>If the buffer object is bound, this function sets client_pointer to NULL (representing the start of the buffer object in server memory); if the buffer object is not bound, this function sets client_pointer the pointer to the data array in client memory, that is, the data array passed in.</p>
<p>If force is not true, the function may return false indicating the data is not currently available.</p>
<p>Creates a new retained-mode representation of the given data, and returns a newly-allocated <a class="el" href="classIndexBufferContext.html">IndexBufferContext</a> pointer to reference it. It is the responsibility of the calling function to later call release_index_buffer() with this same pointer (which will also delete the pointer).</p>
<p>This function should not be called directly to prepare a buffer. Instead, call <a class="el" href="classGeom.html#a0bf675037d2a13dfefa176d7c2be0486">Geom::prepare()</a>.</p>
<p>Makes the data the currently available data for rendering.</p>
<p>Internal function to bind a buffer object for the indicated primitive's index list, if appropriate, or to unbind a buffer object if it should be rendered from client memory.</p>
<p>If the buffer object is bound, this function sets client_pointer to NULL (representing the start of the buffer object in server memory); if the buffer object is not bound, this function sets client_pointer to to the data array in client memory, that is, the data array passed in.</p>
<p>If force is not true, the function may return false indicating the data is not currently available.</p>
<p>Creates a new retained-mode representation of the given data, and returns a newly-allocated <a class="el" href="classBufferContext.html">BufferContext</a> pointer to reference it. It is the responsibility of the calling function to later call release_shader_buffer() with this same pointer (which will also delete the pointer).</p>
<p>This function should not be called directly to prepare a buffer. Instead, call <a class="el" href="classShaderBuffer.html#a81aa24bb98712ad55c9db017e8d8ad1e">ShaderBuffer::prepare()</a>.</p>
<p>This method should only be called by the <a class="el" href="classGraphicsEngine.html">GraphicsEngine</a>. Do not call it directly; call GraphicsEngine::extract_texture_data() instead.</p>
<p>This method will be called in the draw thread to download the buffer's current contents synchronously.</p>
<p>Begins a new occlusion query. After this call, you may call begin_draw_primitives() and draw_triangles()/draw_whatever() repeatedly. Eventually, you should call end_occlusion_query() before the end of the frame; that will return a new <a class="el" href="classOcclusionQueryContext.html">OcclusionQueryContext</a> object that will tell you how many pixels represented by the bracketed geometry passed the depth test.</p>
<p>It is not valid to call begin_occlusion_query() between another begin_occlusion_query() .. end_occlusion_query() sequence.</p>
<p>Adds a timer query to the command stream, associated with the given PStats collector index.</p>
<p>A latency query is a special type of timer query that measures the difference between CPU time and GPU time, ie. how far the GPU is behind in processing the commands being generated by the CPU right now.</p>
<p>Dispatches a currently bound compute shader using the given work group counts.</p>
<p>Copy the pixels within the indicated display region from the framebuffer into texture memory.</p>
<p>If z &gt; -1, it is the cube map index or layer index into which to copy.</p>
<p>Copy the pixels within the indicated display region from the framebuffer into system memory, not texture memory. Returns true on success, false on failure.</p>
<p>This completely redefines the ram image of the indicated texture.</p>
<p>Sends the indicated transform matrix to the graphics API to be applied to future vertices.</p>
<p>This transform is the internal_transform, already converted into the GSG's internal coordinate system.</p>
<p>Called when the current <a class="el" href="classShaderAttrib.html">ShaderAttrib</a> state has changed.</p>
<p>Issues the logic operation attribute to the GL.</p>
<p>Creates a depth buffer for shadow mapping. A derived GSG can override this if it knows that a particular buffer type works best for shadow rendering.</p>
<p>Calls glFlush(). Returns the result of glGetError(). The internal implementation of report_errors(). Don't call this function; use report_errors() instead. The return value is true if everything is ok, or false if we should shut down.</p>
<p>Returns an error string for an OpenGL error code.</p>
<p>Outputs the result of glGetString() on the indicated tag. The output string is returned.</p>
<p>Queries the runtime version of OpenGL in use.</p>
<p>Queries the supported GLSL version.</p>
<p>Separates the string returned by GL_EXTENSIONS (or glx or wgl extensions) into its individual tokens and saves them in the _extensions member.</p>
<p>This may be redefined by a derived class (e.g. glx or wgl) to get whatever further extensions strings may be appropriate to that interface, in addition to the GL extension strings return by glGetString().</p>
<p>Outputs the list of GL extensions to notify, if debug mode is enabled. Returns the pointer to the GL extension function with the indicated name, or NULL if the function is not available.</p>
<p>This is the virtual implementation of get_extension_func(). Each API- specific GL implementation will map this method to the appropriate API call to retrieve the extension function pointer. Returns NULL if the function is not available.</p>
<p>Sets up the glDrawBuffer to render into the buffer indicated by the <a class="el" href="classRenderBuffer.html">RenderBuffer</a> object. This only sets up the color and aux bits; it does not affect the depth, stencil, accum layers.</p>
<p>Sets up the glReadBuffer to render into the buffer indicated by the <a class="el" href="classRenderBuffer.html">RenderBuffer</a> object. This only sets up the color bits; it does not affect the depth, stencil, accum layers.</p>
<p>Maps from the <a class="el" href="classGeom.html">Geom</a>'s internal numeric type symbols to GL's.</p>
<p>Maps from the <a class="el" href="classTexture.html">Texture</a>'s texture type symbols to GL's. Maps from the <a class="el" href="classTexture.html">Texture</a>'s internal wrap mode symbols to GL's. Maps from the GL's internal wrap mode symbols to Panda's.</p>
<p>Maps from the <a class="el" href="classTexture.html">Texture</a>'s internal filter type symbols to GL's.</p>
<p>Maps from the GL's internal filter type symbols to Panda's.</p>
<p>Maps from the <a class="el" href="classTexture.html">Texture</a>'s internal ComponentType symbols to GL's.</p>
<p>Maps from the <a class="el" href="classTexture.html">Texture</a>'s Format symbols to GL's. Maps from the <a class="el" href="classTexture.html">Texture</a>'s Format symbols to a suitable internal format for GL textures. Returns true if the indicated GL minfilter type represents a mipmap format, false otherwise.</p>
<p>Returns true if the indicated GL internal format represents a compressed texture format, false otherwise.</p>
<p>Maps from the texture stage's mode types to the corresponding OpenGL ids</p>
<p>Maps from the texture stage's CombineMode types to the corresponding OpenGL ids</p>
<p>Maps from the texture stage's CombineSource types to the corresponding OpenGL ids Maps from the texture stage's CombineOperand types to the corresponding OpenGL ids</p>
<p>Maps from ColorBlendAttrib::Mode to glBlendEquation value.</p>
<p>Maps from ColorBlendAttrib::Operand to glBlendFunc value.</p>
<p>Maps from UsageHint to the GL symbol.</p>
<p>Returns a string describing an compression format.</p>
<p>Returns the value that that should be issued as the light's color, as scaled by the current value of _light_color_scale, in the case of color_scale_via_lighting. Called by clear_state_and_transform() to ensure that the current modelview and projection matrices are properly loaded in the graphics state, after a callback might have mucked them up.</p>
<p>Simultaneously resets the render state and the transform state.</p>
<p>This transform specified is the "internal" net transform, already converted into the GSG's internal coordinate space by composing it to get_cs_transform(). (Previously, this used to be the "external" net transform, with the assumption that that GSG would convert it internally, but that is no longer the case.)</p>
<p>Special case: if (state==NULL), then the target state is already stored in _target.</p>
<p>Frees some memory that was explicitly allocated within the glgsg.</p>
<p>Returns a Cg context for this GSG. This is called by set_state_and_transform() when the texture state has changed.</p>
<p>Applies a white dummy texture. This is useful to bind to a texture slot when a texture is missing. Also binds the default sampler to the unit.</p>
<p>Returns a white dummy texture. This is useful to bind to a texture slot when a texture is missing.</p>
<p>This is a special function that loads the usage textures in gl-show- texture-usage mode, instead of loading the actual used textures.</p>
<p>If the indicated stage_index is &gt;= 0, then it is the particular texture that is shown. Otherwise, the textures are rotated through based on show_texture_usage_index.</p>
<p>Uploads a special "usage" texture intended to be applied only in gl-show- texture-usage mode, to reveal where texture memory is being spent.</p>
<p>Specifies the texture parameters. Returns true if the texture may need to be reloaded. Pass non-NULL sampler argument to use different sampler settings.</p>
<p>Updates OpenGL with the current information for this texture, and makes it the current texture available for rendering.</p>
<p>The texture needs to have valid storage, call update_texture() first.</p>
<p>Updates OpenGL with the current information for this sampler, and makes it the current sampler available for rendering. Use NULL to unbind the sampler.</p>
<p>If the GSG doesn't support sampler objects, the sampler settings are applied to the given texture context instead.</p>
<p>Uploads the entire texture image to OpenGL, including all pages.</p>
<p>It does not need to be currently bound.</p>
<p>The return value is true if successful, or false if the texture has no image.</p>
<p>Loads a texture image, or one page of a cube map image, from system RAM to texture memory.</p>
<p>Performs the actual OpenGL call to update the texture data for the given mipmap level (be sure to subtract the mipmap_bias before passing it in).</p>
<p>If full_reload is true, recreates the texture storage, otherwise subloads into the existing texture storage. A texture storage with undefined contents can be created by setting image_ptr to nullptr, in which case compressed must be false.</p>
<p>Returns true if this texture format was supported, false otherwise.</p>
<p>Causes mipmaps to be generated for an uploaded texture.</p>
<p>This is used as a standin for upload_texture when the texture in question is unavailable (e.g. it hasn't yet been loaded from disk). Until the texture image itself becomes available, we will render the texture's "simple" image&ndash;a sharply reduced version of the same texture.</p>
<p>Asks OpenGL how much texture memory is consumed by the indicated texture (which is also the currently-selected texture).</p>
<p>Checks the list of resident texture objects to see if any have recently been evicted.</p>
<p>The internal implementation of extract_texture_data(), given an already- created <a class="el" href="classTextureContext.html">TextureContext</a>.</p>
<p>Assumes that the texture is already bound.</p>
<p>Called from extract_texture_data(), this gets just the image array for a particular mipmap level (or for the base image).</p>
<p>Internally sets the point size parameters after any of the properties have changed that might affect this. Returns true if this particular GSG supports the specified Cg <a class="el" href="classShader.html">Shader</a> Profile. Binds a framebuffer object.</p>
<p>Set stencil render states.</p>
<p>Maps a buffer for reading. May be temporarily bound to the given target.</p>
<p>Maps a buffer as write-only, discarding the previous contents. If create_storage is true, allocates new storage for the buffer. May use the given target to temporarily bind the buffer, if DSA is not supported.</p>
<p>Inserts a fence into the command stream.</p>
<p>Checks which fences are finished and processes those.</p>
<p>Adds a job to the queue to be processed later while the context is bound, useful for calling from other threads.</p>
<p>Processes any pending jobs from the queue. If wait is true, waits for at least one job if the queue is empty.</p>
<p>May only be called on the draw thread. </p>

</div>
</div>
<a id="a25fc983f3b6c4814356cfb81598ae7ed" name="a25fc983f3b6c4814356cfb81598ae7ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25fc983f3b6c4814356cfb81598ae7ed">&#9670;&#160;</a></span>CPT()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CPT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTransformState.html">TransformState</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a lens, calculates the appropriate projection matrix for use with this gsg. Note that the projection matrix depends a lot upon the coordinate system of the rendering API.</p>
<p>The return value is a <a class="el" href="classTransformState.html">TransformState</a> if the lens is acceptable, NULL if it is not. </p>

</div>
</div>
<a id="ad8c051e9395293f1d0b23f5b002e4157" name="ad8c051e9395293f1d0b23f5b002e4157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c051e9395293f1d0b23f5b002e4157">&#9670;&#160;</a></span>PT() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeomMunger.html">GeomMunger</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new <a class="el" href="classGeomMunger.html">GeomMunger</a> object to munge vertices appropriate to this GSG for the indicated state. </p>

</div>
</div>
<a id="a21aea0bf7f25e37b8a3475e745d87b6e" name="a21aea0bf7f25e37b8a3475e745d87b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aea0bf7f25e37b8a3475e745d87b6e">&#9670;&#160;</a></span>PT() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PT </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOcclusionQueryContext.html">OcclusionQueryContext</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ends a previous call to begin_occlusion_query(). This call returns the <a class="el" href="classOcclusionQueryContext.html">OcclusionQueryContext</a> object that will (eventually) report the number of pixels that passed the depth test between the call to begin_occlusion_query() and end_occlusion_query(). </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
