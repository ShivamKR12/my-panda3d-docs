<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D C++ Architecture: PreparedGraphicsObjects Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Panda3D C++ Architecture
   </div>
   <div id="projectbrief">API reference for Panda3D&#39;s C++ codebase.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPreparedGraphicsObjects-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">PreparedGraphicsObjects Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="preparedGraphicsObjects_8h_source.html">preparedGraphicsObjects.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PreparedGraphicsObjects:</div>
<div class="dyncontent">
<div class="center"><img src="classPreparedGraphicsObjects__inherit__graph.png" border="0" usemap="#aPreparedGraphicsObjects_inherit__map" alt="Inheritance graph"/></div>
<map name="aPreparedGraphicsObjects_inherit__map" id="aPreparedGraphicsObjects_inherit__map">
<area shape="rect" title=" " alt="" coords="5,151,257,175"/>
<area shape="rect" href="classReferenceCount.html" title=" " alt="" coords="50,78,212,103"/>
<area shape="poly" title=" " alt="" coords="134,119,134,150,128,150,128,119"/>
<area shape="rect" href="classMemoryBase.html" title=" " alt="" coords="70,5,192,30"/>
<area shape="poly" title=" " alt="" coords="134,46,134,78,128,78,128,46"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for PreparedGraphicsObjects:</div>
<div class="dyncontent">
<div class="center"><img src="classPreparedGraphicsObjects__coll__graph.png" border="0" usemap="#aPreparedGraphicsObjects_coll__map" alt="Collaboration graph"/></div>
<map name="aPreparedGraphicsObjects_coll__map" id="aPreparedGraphicsObjects_coll__map">
<area shape="rect" title=" " alt="" coords="1226,90565,1477,90590"/>
<area shape="rect" href="classReferenceCount.html" title=" " alt="" coords="541,45202,703,45227"/>
<area shape="poly" title=" " alt="" coords="621,45187,649,37632,681,30409,724,22228,777,14097,807,10364,840,7021,874,4192,911,2005,930,1190,949,583,969,200,979,96,990,53,1016,31,1042,15,1070,6,1097,3,1125,6,1152,15,1178,31,1204,54,1210,124,1215,321,1225,1076,1243,3925,1259,8344,1274,14072,1300,28420,1320,44894,1345,75924,1353,90565,1348,90565,1340,75924,1315,44894,1295,28420,1269,14072,1254,8344,1237,3925,1219,1076,1209,321,1204,125,1200,56,1175,35,1150,20,1123,11,1097,8,1071,11,1045,20,1019,35,994,56,984,97,974,200,954,584,935,1190,916,2005,880,4192,845,7021,813,10364,783,14097,730,22228,687,30409,655,37632,626,45187"/>
<area shape="rect" href="classMemoryBase.html" title=" " alt="" coords="35,79110,157,79135"/>
<area shape="poly" title=" " alt="" coords="95,79095,618,45228,623,45228,100,79095"/>
<area shape="rect" href="classNamable.html" title=" " alt="" coords="331,90477,422,90502"/>
<area shape="poly" title=" " alt="" coords="101,79151,378,90476,372,90476,95,79151"/>
<area shape="rect" href="classBufferResidencyTracker.html" title=" " alt="" coords="727,90538,968,90563"/>
<area shape="poly" title=" " alt="" coords="984,90555,1226,90568,1225,90573,983,90561"/>
<area shape="rect" href="classAdaptiveLru.html" title=" " alt="" coords="782,90637,913,90662"/>
<area shape="poly" title=" " alt="" coords="928,90646,1057,90639,1130,90632,1201,90621,1263,90605,1316,90588,1318,90593,1264,90611,1203,90626,1131,90637,1058,90645,928,90651"/>
<area shape="poly" title=" " alt="" coords="424,90505,542,90547,588,90555,626,90557,663,90563,704,90585,713,90594,717,90604,721,90614,728,90622,754,90635,782,90643,781,90648,752,90640,725,90626,716,90616,712,90606,709,90597,701,90589,661,90568,626,90563,588,90561,541,90552,423,90510"/>
<area shape="rect" href="classSimpleLru.html" title=" " alt="" coords="792,90588,903,90612"/>
<area shape="poly" title=" " alt="" coords="438,90489,496,90495,564,90506,635,90524,704,90551,716,90562,728,90572,759,90584,792,90592,791,90597,758,90590,725,90577,713,90566,701,90556,634,90529,563,90511,495,90500,438,90494"/>
<area shape="rect" href="classLightMutex.html" title=" " alt="" coords="316,90554,437,90579"/>
<area shape="poly" title=" " alt="" coords="452,90580,542,90598,781,90637,781,90643,541,90603,451,90585"/>
<area shape="poly" title=" " alt="" coords="453,90566,703,90580,792,90590,791,90595,702,90585,453,90572"/>
<area shape="rect" href="classLightMutexDirect.html" title=" " alt="" coords="5,90554,187,90579"/>
<area shape="poly" title=" " alt="" coords="202,90564,316,90564,316,90569,202,90569"/>
<area shape="rect" href="classAdaptiveLruPageDynamicList.html" title=" " alt="" coords="236,90684,517,181151"/>
<area shape="poly" title=" " alt="" coords="515,122361,843,90662,849,90662,521,122361"/>
<area shape="rect" href="classLinkedListNode.html" title=" " alt="" coords="15,90683,177,181151"/>
<area shape="poly" title=" " alt="" coords="192,135915,236,135915,236,135920,192,135920"/>
<area shape="poly" title=" " alt="" coords="93,90668,96,90657,100,90683,95,90683,96,90662,98,90668"/>
<area shape="rect" href="classAdaptiveLruPageStaticList.html" title=" " alt="" coords="241,181174,512,181199"/>
<area shape="poly" title=" " alt="" coords="180,175362,193,177744,207,179567,222,180738,230,181049,238,181162,250,181172,246,181176,234,181164,225,181050,217,180738,202,179567,188,177744,175,175362"/>
<area shape="poly" title=" " alt="" coords="175,96097,188,93864,202,92159,217,91067,225,90777,234,90671,250,90657,271,90646,324,90632,387,90626,457,90624,596,90628,656,90628,702,90625,791,90609,792,90615,703,90631,656,90634,596,90633,457,90629,388,90631,325,90637,273,90651,253,90661,238,90673,230,90777,222,91067,207,92159,193,93864,180,96097"/>
<area shape="poly" title=" " alt="" coords="514,181162,515,181162,524,181087,533,180885,552,180120,569,178900,587,177255,620,172827,651,167093,680,160312,707,152744,754,136279,792,119769,820,105283,843,90662,849,90662,825,105283,797,119769,759,136280,712,152744,685,160312,656,167093,625,172827,592,177256,575,178900,557,180120,539,180886,529,181087,520,181164,518,181166"/>
<area shape="poly" title=" " alt="" coords="918,90600,1050,90601,1202,90595,1271,90588,1272,90593,1202,90601,1050,90606,918,90605"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects_1_1EnqueuedObject.html">EnqueuedObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aa13d5058568db17f29dc3e031e4289e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#aa13d5058568db17f29dc3e031e4289e3">set_graphics_memory_limit</a> (size_t limit)</td></tr>
<tr class="separator:aa13d5058568db17f29dc3e031e4289e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac432e26d5dfd6ec1a2a5d690643c28fd"><td class="memItemLeft" align="right" valign="top"><a id="ac432e26d5dfd6ec1a2a5d690643c28fd" name="ac432e26d5dfd6ec1a2a5d690643c28fd"></a>
INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><b>get_graphics_memory_limit</b> () const</td></tr>
<tr class="separator:ac432e26d5dfd6ec1a2a5d690643c28fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6967e94f5246f34ee2ef4206db067d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#abc6967e94f5246f34ee2ef4206db067d">show_graphics_memory_lru</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:abc6967e94f5246f34ee2ef4206db067d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4715494b08a64b0087e573e7feb96be0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a4715494b08a64b0087e573e7feb96be0">show_residency_trackers</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a4715494b08a64b0087e573e7feb96be0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a905f85b9284aeb8a89c5f2fa3096f063"><td class="memItemLeft" align="right" valign="top"><a id="a905f85b9284aeb8a89c5f2fa3096f063" name="a905f85b9284aeb8a89c5f2fa3096f063"></a>
INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>release_all</b> ()</td></tr>
<tr class="separator:a905f85b9284aeb8a89c5f2fa3096f063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38123fc665a4471b68886e565e0daf64"><td class="memItemLeft" align="right" valign="top"><a id="a38123fc665a4471b68886e565e0daf64" name="a38123fc665a4471b68886e565e0daf64"></a>
INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_queued</b> () const</td></tr>
<tr class="separator:a38123fc665a4471b68886e565e0daf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52054604a4dab2a8d3dfe8d441f6acd3"><td class="memItemLeft" align="right" valign="top"><a id="a52054604a4dab2a8d3dfe8d441f6acd3" name="a52054604a4dab2a8d3dfe8d441f6acd3"></a>
INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>get_num_prepared</b> () const</td></tr>
<tr class="separator:a52054604a4dab2a8d3dfe8d441f6acd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45db9601d0aaea6961a93b8e6e228a7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a45db9601d0aaea6961a93b8e6e228a7a">enqueue_texture</a> (<a class="el" href="classTexture.html">Texture</a> *tex)</td></tr>
<tr class="separator:a45db9601d0aaea6961a93b8e6e228a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d89b003463ec85b48a67832f65246"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a1f8d89b003463ec85b48a67832f65246">is_texture_queued</a> (const <a class="el" href="classTexture.html">Texture</a> *tex) const</td></tr>
<tr class="separator:a1f8d89b003463ec85b48a67832f65246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8955cb8109a28da78f52de756baa1e8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#aa8955cb8109a28da78f52de756baa1e8">dequeue_texture</a> (<a class="el" href="classTexture.html">Texture</a> *tex)</td></tr>
<tr class="separator:aa8955cb8109a28da78f52de756baa1e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c1ffea82760bf8132a147435f52d4ca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a5c1ffea82760bf8132a147435f52d4ca">is_texture_prepared</a> (const <a class="el" href="classTexture.html">Texture</a> *tex) const</td></tr>
<tr class="separator:a5c1ffea82760bf8132a147435f52d4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34c2d5663ee60380dc3b4d11c65452d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#af34c2d5663ee60380dc3b4d11c65452d">release_texture</a> (<a class="el" href="classTextureContext.html">TextureContext</a> *tc)</td></tr>
<tr class="separator:af34c2d5663ee60380dc3b4d11c65452d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25769173593d65f4ac03882a41a7a551"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a25769173593d65f4ac03882a41a7a551">release_texture</a> (<a class="el" href="classTexture.html">Texture</a> *tex)</td></tr>
<tr class="separator:a25769173593d65f4ac03882a41a7a551"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dbf284d46e9fef6cb667c58dc3537d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a25dbf284d46e9fef6cb667c58dc3537d">release_all_textures</a> ()</td></tr>
<tr class="separator:a25dbf284d46e9fef6cb667c58dc3537d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2bc29d67f057461567e046d0be1d90"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a7b2bc29d67f057461567e046d0be1d90">get_num_queued_textures</a> () const</td></tr>
<tr class="separator:a7b2bc29d67f057461567e046d0be1d90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed4062fcfe4fc44554d170eab416c16"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a3ed4062fcfe4fc44554d170eab416c16">get_num_prepared_textures</a> () const</td></tr>
<tr class="separator:a3ed4062fcfe4fc44554d170eab416c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae704ff16e42ab4959e725c1af7478658"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTextureContext.html">TextureContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ae704ff16e42ab4959e725c1af7478658">prepare_texture_now</a> (<a class="el" href="classTexture.html">Texture</a> *tex, <a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *gsg)</td></tr>
<tr class="separator:ae704ff16e42ab4959e725c1af7478658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42de2dc2d52a0974865984b17886696b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a42de2dc2d52a0974865984b17886696b">enqueue_sampler</a> (const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;sampler)</td></tr>
<tr class="separator:a42de2dc2d52a0974865984b17886696b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e61009f472eeb7bfb2ba807180b221"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a81e61009f472eeb7bfb2ba807180b221">is_sampler_queued</a> (const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;sampler) const</td></tr>
<tr class="separator:a81e61009f472eeb7bfb2ba807180b221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877f59c985f9213e7cc6e666322eebbe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a877f59c985f9213e7cc6e666322eebbe">dequeue_sampler</a> (const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;sampler)</td></tr>
<tr class="separator:a877f59c985f9213e7cc6e666322eebbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ab8c5017701a3273400ffa400d6b5a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a78ab8c5017701a3273400ffa400d6b5a">is_sampler_prepared</a> (const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;sampler) const</td></tr>
<tr class="separator:a78ab8c5017701a3273400ffa400d6b5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178fa14ef996798fdec0f1afd122c771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a178fa14ef996798fdec0f1afd122c771">release_sampler</a> (<a class="el" href="classSamplerContext.html">SamplerContext</a> *sc)</td></tr>
<tr class="separator:a178fa14ef996798fdec0f1afd122c771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937039d2724d0af1c7f6f78c3bc38af3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a937039d2724d0af1c7f6f78c3bc38af3">release_sampler</a> (const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;sampler)</td></tr>
<tr class="separator:a937039d2724d0af1c7f6f78c3bc38af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba0b983ecc27f47c3ccea5f7781c93bd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#aba0b983ecc27f47c3ccea5f7781c93bd">release_all_samplers</a> ()</td></tr>
<tr class="separator:aba0b983ecc27f47c3ccea5f7781c93bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e8f636d6b1cc1e3c3059a01972c5f81"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a4e8f636d6b1cc1e3c3059a01972c5f81">get_num_queued_samplers</a> () const</td></tr>
<tr class="separator:a4e8f636d6b1cc1e3c3059a01972c5f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac691b73e37e4b805b24ff5e6e11ba22b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ac691b73e37e4b805b24ff5e6e11ba22b">get_num_prepared_samplers</a> () const</td></tr>
<tr class="separator:ac691b73e37e4b805b24ff5e6e11ba22b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48fa5e9fac61516d64cfd383f90c8954"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSamplerContext.html">SamplerContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a48fa5e9fac61516d64cfd383f90c8954">prepare_sampler_now</a> (const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;sampler, <a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *gsg)</td></tr>
<tr class="separator:a48fa5e9fac61516d64cfd383f90c8954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae994e9bc04c1dd10ef935cce122aacc0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ae994e9bc04c1dd10ef935cce122aacc0">enqueue_geom</a> (<a class="el" href="classGeom.html">Geom</a> *geom)</td></tr>
<tr class="separator:ae994e9bc04c1dd10ef935cce122aacc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9419853618c0c691b12fe509eff54435"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a9419853618c0c691b12fe509eff54435">is_geom_queued</a> (const <a class="el" href="classGeom.html">Geom</a> *geom) const</td></tr>
<tr class="separator:a9419853618c0c691b12fe509eff54435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54dc4c1cfa5591ec1dc4d4d20cf4544"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ac54dc4c1cfa5591ec1dc4d4d20cf4544">dequeue_geom</a> (<a class="el" href="classGeom.html">Geom</a> *geom)</td></tr>
<tr class="separator:ac54dc4c1cfa5591ec1dc4d4d20cf4544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bccb7827e030552ed18dd9151ec5754"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a4bccb7827e030552ed18dd9151ec5754">is_geom_prepared</a> (const <a class="el" href="classGeom.html">Geom</a> *geom) const</td></tr>
<tr class="separator:a4bccb7827e030552ed18dd9151ec5754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c53457f4c0eb29752970b309d8b86c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a30c53457f4c0eb29752970b309d8b86c">release_geom</a> (<a class="el" href="classGeomContext.html">GeomContext</a> *gc)</td></tr>
<tr class="separator:a30c53457f4c0eb29752970b309d8b86c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f00472736ce5eebb4dc2b226e1e6bce"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a0f00472736ce5eebb4dc2b226e1e6bce">release_all_geoms</a> ()</td></tr>
<tr class="separator:a0f00472736ce5eebb4dc2b226e1e6bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08733a06d2183dbf22acb6467a66768b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a08733a06d2183dbf22acb6467a66768b">get_num_queued_geoms</a> () const</td></tr>
<tr class="separator:a08733a06d2183dbf22acb6467a66768b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9839688f4e1bfa32a48d55a702948f22"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a9839688f4e1bfa32a48d55a702948f22">get_num_prepared_geoms</a> () const</td></tr>
<tr class="separator:a9839688f4e1bfa32a48d55a702948f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac80f5c15475dff257ea6e25d5b115f2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGeomContext.html">GeomContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#aac80f5c15475dff257ea6e25d5b115f2">prepare_geom_now</a> (<a class="el" href="classGeom.html">Geom</a> *geom, <a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *gsg)</td></tr>
<tr class="separator:aac80f5c15475dff257ea6e25d5b115f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae89d9f2e64192a1d03ad81524591abf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ae89d9f2e64192a1d03ad81524591abf6">enqueue_shader</a> (<a class="el" href="classShader.html">Shader</a> *shader)</td></tr>
<tr class="separator:ae89d9f2e64192a1d03ad81524591abf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a473b9aad42c05a8d00b3c65c18f6efce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a473b9aad42c05a8d00b3c65c18f6efce">is_shader_queued</a> (const <a class="el" href="classShader.html">Shader</a> *shader) const</td></tr>
<tr class="separator:a473b9aad42c05a8d00b3c65c18f6efce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a541897e01cf3cd0f8fb55b3597c8eeb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a541897e01cf3cd0f8fb55b3597c8eeb3">dequeue_shader</a> (<a class="el" href="classShader.html">Shader</a> *shader)</td></tr>
<tr class="separator:a541897e01cf3cd0f8fb55b3597c8eeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd5cb9dabd93eb67d723c98a634897de"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#acd5cb9dabd93eb67d723c98a634897de">is_shader_prepared</a> (const <a class="el" href="classShader.html">Shader</a> *shader) const</td></tr>
<tr class="separator:acd5cb9dabd93eb67d723c98a634897de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c153ead0efb71422b793e54c90f4cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a98c153ead0efb71422b793e54c90f4cc">release_shader</a> (<a class="el" href="classShaderContext.html">ShaderContext</a> *sc)</td></tr>
<tr class="separator:a98c153ead0efb71422b793e54c90f4cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76828328f3f682fe752fe6548868108c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a76828328f3f682fe752fe6548868108c">release_all_shaders</a> ()</td></tr>
<tr class="separator:a76828328f3f682fe752fe6548868108c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53551f80a69d1a6a9dbcba3a9187d87f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a53551f80a69d1a6a9dbcba3a9187d87f">get_num_queued_shaders</a> () const</td></tr>
<tr class="separator:a53551f80a69d1a6a9dbcba3a9187d87f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2843b80d55a448d3b65aefd0fcabb7e2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a2843b80d55a448d3b65aefd0fcabb7e2">get_num_prepared_shaders</a> () const</td></tr>
<tr class="separator:a2843b80d55a448d3b65aefd0fcabb7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa11213aa7b163caadbbe58d3fbe17ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classShaderContext.html">ShaderContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#afa11213aa7b163caadbbe58d3fbe17ef">prepare_shader_now</a> (<a class="el" href="classShader.html">Shader</a> *shader, <a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *gsg)</td></tr>
<tr class="separator:afa11213aa7b163caadbbe58d3fbe17ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a079c30ee715d902194d78a002f8956d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a079c30ee715d902194d78a002f8956d3">enqueue_vertex_buffer</a> (<a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *data)</td></tr>
<tr class="separator:a079c30ee715d902194d78a002f8956d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9c5184ab1923a62fbd26e50e418406f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ae9c5184ab1923a62fbd26e50e418406f">is_vertex_buffer_queued</a> (const <a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *data) const</td></tr>
<tr class="separator:ae9c5184ab1923a62fbd26e50e418406f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e4bdb510823b3ad5359172953879f67"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a1e4bdb510823b3ad5359172953879f67">dequeue_vertex_buffer</a> (<a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *data)</td></tr>
<tr class="separator:a1e4bdb510823b3ad5359172953879f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e5b057ccd7e849fa18825565ed5939"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ad2e5b057ccd7e849fa18825565ed5939">is_vertex_buffer_prepared</a> (const <a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *data) const</td></tr>
<tr class="separator:ad2e5b057ccd7e849fa18825565ed5939"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66e2cf8ebb5525ddd2a453639382600"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ae66e2cf8ebb5525ddd2a453639382600">release_vertex_buffer</a> (<a class="el" href="classVertexBufferContext.html">VertexBufferContext</a> *vbc)</td></tr>
<tr class="separator:ae66e2cf8ebb5525ddd2a453639382600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70583653a4410fa1b15f1ea56aa1d11"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#af70583653a4410fa1b15f1ea56aa1d11">release_all_vertex_buffers</a> ()</td></tr>
<tr class="separator:af70583653a4410fa1b15f1ea56aa1d11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d68396374634d0a6f3027cd54faf46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a46d68396374634d0a6f3027cd54faf46">get_num_queued_vertex_buffers</a> () const</td></tr>
<tr class="separator:a46d68396374634d0a6f3027cd54faf46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ead49c7cf089235d9e8e49e9100c567"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a2ead49c7cf089235d9e8e49e9100c567">get_num_prepared_vertex_buffers</a> () const</td></tr>
<tr class="separator:a2ead49c7cf089235d9e8e49e9100c567"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeaff6051a1dd128235fb44dd2ac1c59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVertexBufferContext.html">VertexBufferContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#afeaff6051a1dd128235fb44dd2ac1c59">prepare_vertex_buffer_now</a> (<a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *data, <a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *gsg)</td></tr>
<tr class="separator:afeaff6051a1dd128235fb44dd2ac1c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf09abd6c22be7507612524390a07f91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#adf09abd6c22be7507612524390a07f91">enqueue_index_buffer</a> (<a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *data)</td></tr>
<tr class="separator:adf09abd6c22be7507612524390a07f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9ce9afd532179f713985f21e916d3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a9e9ce9afd532179f713985f21e916d3a">is_index_buffer_queued</a> (const <a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *data) const</td></tr>
<tr class="separator:a9e9ce9afd532179f713985f21e916d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8d32c6ab9684ac0df1b14173bc0879"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#aff8d32c6ab9684ac0df1b14173bc0879">dequeue_index_buffer</a> (<a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *data)</td></tr>
<tr class="separator:aff8d32c6ab9684ac0df1b14173bc0879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a319ec66d521c211a7b4eb229909813b7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a319ec66d521c211a7b4eb229909813b7">is_index_buffer_prepared</a> (const <a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *data) const</td></tr>
<tr class="separator:a319ec66d521c211a7b4eb229909813b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac550c095aa65420418a2bf9c4b8c075e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ac550c095aa65420418a2bf9c4b8c075e">release_index_buffer</a> (<a class="el" href="classIndexBufferContext.html">IndexBufferContext</a> *ibc)</td></tr>
<tr class="separator:ac550c095aa65420418a2bf9c4b8c075e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898c6bd1745cb7fb66cd4d7bf504fea4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a898c6bd1745cb7fb66cd4d7bf504fea4">release_all_index_buffers</a> ()</td></tr>
<tr class="separator:a898c6bd1745cb7fb66cd4d7bf504fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4529a94a0633fad3337a269c98b14e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a2d4529a94a0633fad3337a269c98b14e">get_num_queued_index_buffers</a> () const</td></tr>
<tr class="separator:a2d4529a94a0633fad3337a269c98b14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af84ab4d05715ff737b28ac11f8932329"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#af84ab4d05715ff737b28ac11f8932329">get_num_prepared_index_buffers</a> () const</td></tr>
<tr class="separator:af84ab4d05715ff737b28ac11f8932329"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bf742de2512a1a0b4acf3e90ca2ccd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexBufferContext.html">IndexBufferContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#af9bf742de2512a1a0b4acf3e90ca2ccd">prepare_index_buffer_now</a> (<a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *data, <a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *gsg)</td></tr>
<tr class="separator:af9bf742de2512a1a0b4acf3e90ca2ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb7ec2bae9d28c4c0548ec609eeb8e51"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#afb7ec2bae9d28c4c0548ec609eeb8e51">enqueue_shader_buffer</a> (<a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *data)</td></tr>
<tr class="separator:afb7ec2bae9d28c4c0548ec609eeb8e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a524e4abd51279265c34df3c2213d6726"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a524e4abd51279265c34df3c2213d6726">is_shader_buffer_queued</a> (const <a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *data) const</td></tr>
<tr class="separator:a524e4abd51279265c34df3c2213d6726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0e3898509b4b30d463edd780a18d693"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ac0e3898509b4b30d463edd780a18d693">dequeue_shader_buffer</a> (<a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *data)</td></tr>
<tr class="separator:ac0e3898509b4b30d463edd780a18d693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06e2cc9cf2af3540bb5088ab92a7c58"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#aa06e2cc9cf2af3540bb5088ab92a7c58">is_shader_buffer_prepared</a> (const <a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *data) const</td></tr>
<tr class="separator:aa06e2cc9cf2af3540bb5088ab92a7c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6880461c92f69406e37e4257d3f24c88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a6880461c92f69406e37e4257d3f24c88">release_shader_buffer</a> (<a class="el" href="classBufferContext.html">BufferContext</a> *bc)</td></tr>
<tr class="separator:a6880461c92f69406e37e4257d3f24c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c965ce640c2a987edf76bc4192f1123"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a9c965ce640c2a987edf76bc4192f1123">release_all_shader_buffers</a> ()</td></tr>
<tr class="separator:a9c965ce640c2a987edf76bc4192f1123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f6a71dc0d6edd72c7a21ebe1bca785"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#af4f6a71dc0d6edd72c7a21ebe1bca785">get_num_queued_shader_buffers</a> () const</td></tr>
<tr class="separator:af4f6a71dc0d6edd72c7a21ebe1bca785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e05737b7c1be108200cbaab6ca38219"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#a2e05737b7c1be108200cbaab6ca38219">get_num_prepared_shader_buffers</a> () const</td></tr>
<tr class="separator:a2e05737b7c1be108200cbaab6ca38219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12ac6231b3b0635344d226536aa05a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBufferContext.html">BufferContext</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ae12ac6231b3b0635344d226536aa05a7">prepare_shader_buffer_now</a> (<a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *data, <a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *gsg)</td></tr>
<tr class="separator:ae12ac6231b3b0635344d226536aa05a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e077e2a305314a58e2db4eb38e2a117"><td class="memItemLeft" align="right" valign="top"><a id="a8e077e2a305314a58e2db4eb38e2a117" name="a8e077e2a305314a58e2db4eb38e2a117"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PT</b> (<a class="el" href="classPreparedGraphicsObjects_1_1EnqueuedObject.html">EnqueuedObject</a>) enqueue_texture_future(<a class="el" href="classTexture.html">Texture</a> *tex)</td></tr>
<tr class="separator:a8e077e2a305314a58e2db4eb38e2a117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b8afe4d1336feff712777cddb01ef4"><td class="memItemLeft" align="right" valign="top"><a id="a60b8afe4d1336feff712777cddb01ef4" name="a60b8afe4d1336feff712777cddb01ef4"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PT</b> (<a class="el" href="classPreparedGraphicsObjects_1_1EnqueuedObject.html">EnqueuedObject</a>) enqueue_shader_future(<a class="el" href="classShader.html">Shader</a> *shader)</td></tr>
<tr class="separator:a60b8afe4d1336feff712777cddb01ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96b7c6ca74936b909b764d473dd7507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ad96b7c6ca74936b909b764d473dd7507">begin_frame</a> (<a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *gsg, <a class="el" href="classThread.html">Thread</a> *current_thread)</td></tr>
<tr class="separator:ad96b7c6ca74936b909b764d473dd7507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cda370924af2053e2920e42790f83e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPreparedGraphicsObjects.html#ab5cda370924af2053e2920e42790f83e">end_frame</a> (<a class="el" href="classThread.html">Thread</a> *current_thread)</td></tr>
<tr class="separator:ab5cda370924af2053e2920e42790f83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classReferenceCount')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:af72a1e7f896a240fb48903cbdcd8db13 inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>ref</b> () const</td></tr>
<tr class="separator:af72a1e7f896a240fb48903cbdcd8db13 inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4255ad6eaf360a2a4648ded8152591e inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">virtual INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReferenceCount.html#ab4255ad6eaf360a2a4648ded8152591e">unref</a> () const</td></tr>
<tr class="separator:ab4255ad6eaf360a2a4648ded8152591e inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0113c8a18e99cf93397e6c4c694ad5 inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_PROPERTY</b> (ref_count, get_ref_count)</td></tr>
<tr class="separator:a4c0113c8a18e99cf93397e6c4c694ad5 inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976a0726476379d60563458f394d68ab inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_ref_count_integrity</b> () const</td></tr>
<tr class="separator:a976a0726476379d60563458f394d68ab inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceafbd7d04812067e1febaa9ec89470d inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>test_ref_count_nonzero</b> () const</td></tr>
<tr class="separator:aceafbd7d04812067e1febaa9ec89470d inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c13c3407851c911649ebdc06c2520f inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>local_object</b> ()</td></tr>
<tr class="separator:af7c13c3407851c911649ebdc06c2520f inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad528fb0265c37c122436a7b3eb630dc6 inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>has_weak_list</b> () const</td></tr>
<tr class="separator:ad528fb0265c37c122436a7b3eb630dc6 inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d9c6404a66b0e86c3330511470918a inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE <a class="el" href="classWeakReferenceList.html">WeakReferenceList</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_weak_list</b> () const</td></tr>
<tr class="separator:af5d9c6404a66b0e86c3330511470918a inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7508d67fd656db60508a8ab21d80cbf inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE <a class="el" href="classWeakReferenceList.html">WeakReferenceList</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>weak_ref</b> ()</td></tr>
<tr class="separator:af7508d67fd656db60508a8ab21d80cbf inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254403c6b0e0ae0849c76999cd53498d inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>weak_unref</b> ()</td></tr>
<tr class="separator:a254403c6b0e0ae0849c76999cd53498d inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab536c5345647beb142c34da994e49075 inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>ref_if_nonzero</b> () const</td></tr>
<tr class="separator:ab536c5345647beb142c34da994e49075 inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33dad090f47a7d85a12b9d6b8ef787d inherit pub_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>unref_if_one</b> () const</td></tr>
<tr class="separator:ae33dad090f47a7d85a12b9d6b8ef787d inherit pub_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a045ede43daf6674a5c227bc6ffdbdbda"><td class="memItemLeft" align="right" valign="top"><a id="a045ede43daf6674a5c227bc6ffdbdbda" name="a045ede43daf6674a5c227bc6ffdbdbda"></a>
PUBLISHED&#160;</td><td class="memItemRight" valign="bottom">: INLINE const std::string &amp;get_name() const</td></tr>
<tr class="separator:a045ede43daf6674a5c227bc6ffdbdbda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c9498760303573617ab68de760763a"><td class="memItemLeft" align="right" valign="top"><a id="a85c9498760303573617ab68de760763a" name="a85c9498760303573617ab68de760763a"></a>
<a class="el" href="classBufferResidencyTracker.html">BufferResidencyTracker</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_texture_residency</b></td></tr>
<tr class="separator:a85c9498760303573617ab68de760763a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a36414ad4c9f5ee2e6f5f455db7e316"><td class="memItemLeft" align="right" valign="top"><a id="a7a36414ad4c9f5ee2e6f5f455db7e316" name="a7a36414ad4c9f5ee2e6f5f455db7e316"></a>
<a class="el" href="classBufferResidencyTracker.html">BufferResidencyTracker</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_vbuffer_residency</b></td></tr>
<tr class="separator:a7a36414ad4c9f5ee2e6f5f455db7e316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa351c3963f4bdbb3deb3fc16ffcd853a"><td class="memItemLeft" align="right" valign="top"><a id="aa351c3963f4bdbb3deb3fc16ffcd853a" name="aa351c3963f4bdbb3deb3fc16ffcd853a"></a>
<a class="el" href="classBufferResidencyTracker.html">BufferResidencyTracker</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_ibuffer_residency</b></td></tr>
<tr class="separator:aa351c3963f4bdbb3deb3fc16ffcd853a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08bcfcc3c59c59f9a1ecb4ae97e17e4e"><td class="memItemLeft" align="right" valign="top"><a id="a08bcfcc3c59c59f9a1ecb4ae97e17e4e" name="a08bcfcc3c59c59f9a1ecb4ae97e17e4e"></a>
<a class="el" href="classBufferResidencyTracker.html">BufferResidencyTracker</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_sbuffer_residency</b></td></tr>
<tr class="separator:a08bcfcc3c59c59f9a1ecb4ae97e17e4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b31f64002c59f5246dc81fbf4ebc964"><td class="memItemLeft" align="right" valign="top"><a id="a8b31f64002c59f5246dc81fbf4ebc964" name="a8b31f64002c59f5246dc81fbf4ebc964"></a>
<a class="el" href="classAdaptiveLru.html">AdaptiveLru</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_graphics_memory_lru</b></td></tr>
<tr class="separator:a8b31f64002c59f5246dc81fbf4ebc964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6febd0ff8f0408fe2c47990c82df7bb"><td class="memItemLeft" align="right" valign="top"><a id="ae6febd0ff8f0408fe2c47990c82df7bb" name="ae6febd0ff8f0408fe2c47990c82df7bb"></a>
<a class="el" href="classSimpleLru.html">SimpleLru</a>&#160;</td><td class="memItemRight" valign="bottom"><b>_sampler_object_lru</b></td></tr>
<tr class="separator:ae6febd0ff8f0408fe2c47990c82df7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accebdf7528e8d45fb88fef692c94e02c"><td class="memItemLeft" align="right" valign="top"><a id="accebdf7528e8d45fb88fef692c94e02c" name="accebdf7528e8d45fb88fef692c94e02c"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>_support_released_buffer_cache</b></td></tr>
<tr class="separator:accebdf7528e8d45fb88fef692c94e02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classReferenceCount')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a30df4133ffc37e9d4b78c3dfe7440fe9 inherit pub_attribs_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
PUBLISHED&#160;</td><td class="memItemRight" valign="bottom">: INLINE int get_ref_count() const</td></tr>
<tr class="separator:a30df4133ffc37e9d4b78c3dfe7440fe9 inherit pub_attribs_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classMemoryBase"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classMemoryBase')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classMemoryBase.html">MemoryBase</a></td></tr>
<tr class="memitem:aaa0812a01210684812d2df819684c997 inherit pub_attribs_classMemoryBase"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ALLOC_MEMORY_BASE</b></td></tr>
<tr class="separator:aaa0812a01210684812d2df819684c997 inherit pub_attribs_classMemoryBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2f7de8ab6ded774b94f7829733f6a96f"><td class="memItemLeft" align="right" valign="top"><a id="a2f7de8ab6ded774b94f7829733f6a96f" name="a2f7de8ab6ded774b94f7829733f6a96f"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>GraphicsStateGuardian</b></td></tr>
<tr class="separator:a2f7de8ab6ded774b94f7829733f6a96f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="inherited" name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classReferenceCount')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:a812b7eb0c990b6c3d9c674a18cf8143e inherit pub_static_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
static <a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><b>get_class_type</b> ()</td></tr>
<tr class="separator:a812b7eb0c990b6c3d9c674a18cf8143e inherit pub_static_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a382c8e7d2ad04bff7e08ae3e4ab52382 inherit pub_static_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
static void&#160;</td><td class="memItemRight" valign="bottom"><b>init_type</b> ()</td></tr>
<tr class="separator:a382c8e7d2ad04bff7e08ae3e4ab52382 inherit pub_static_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classReferenceCount"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classReferenceCount')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classReferenceCount.html">ReferenceCount</a></td></tr>
<tr class="memitem:aba3dc9d9ba85eb7f9b63befcb2afe0b2 inherit pro_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE&#160;</td><td class="memItemRight" valign="bottom"><b>ReferenceCount</b> (const <a class="el" href="classReferenceCount.html">ReferenceCount</a> &amp;)</td></tr>
<tr class="separator:aba3dc9d9ba85eb7f9b63befcb2afe0b2 inherit pro_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a090b77bc64aef11f835a30208ca4b22e inherit pro_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">
INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>operator=</b> (const <a class="el" href="classReferenceCount.html">ReferenceCount</a> &amp;)</td></tr>
<tr class="separator:a090b77bc64aef11f835a30208ca4b22e inherit pro_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20d3ab642d6a47f4d6ebeb1bc1f859d9 inherit pro_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReferenceCount.html#a20d3ab642d6a47f4d6ebeb1bc1f859d9">do_test_ref_count_integrity</a> () const</td></tr>
<tr class="separator:a20d3ab642d6a47f4d6ebeb1bc1f859d9 inherit pro_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a923e004bbf03fea6fc6533a75e3992f1 inherit pro_methods_classReferenceCount"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classReferenceCount.html#a923e004bbf03fea6fc6533a75e3992f1">do_test_ref_count_nonzero</a> () const</td></tr>
<tr class="separator:a923e004bbf03fea6fc6533a75e3992f1 inherit pro_methods_classReferenceCount"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A table of objects that are saved within the graphics context for reference by handle later. Generally, this represents things like OpenGL texture objects or display lists (or their equivalent on other platforms).</p>
<p>This object simply records the pointers to the context objects created by the individual GSG's; these context objects will contain enough information to reference or release the actual object stored within the graphics context.</p>
<p>These tables may potentially be shared between related graphics contexts, hence their storage here in a separate object rather than as a part of the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a>. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ad96b7c6ca74936b909b764d473dd7507" name="ad96b7c6ca74936b909b764d473dd7507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96b7c6ca74936b909b764d473dd7507">&#9670;&#160;</a></span>begin_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::begin_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *&#160;</td>
          <td class="paramname"><em>gsg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classThread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>current_thread</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is called by the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> to indicate that it is about to begin processing of the frame.</p>
<p>Any texture contexts that were previously passed to <a class="el" href="classPreparedGraphicsObjects.html#af34c2d5663ee60380dc3b4d11c65452d">release_texture()</a> are actually passed to the GSG to be freed at this point; textures that were previously passed to prepare_texture are actually loaded. </p>

</div>
</div>
<a id="ac54dc4c1cfa5591ec1dc4d4d20cf4544" name="ac54dc4c1cfa5591ec1dc4d4d20cf4544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac54dc4c1cfa5591ec1dc4d4d20cf4544">&#9670;&#160;</a></span>dequeue_geom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::dequeue_geom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeom.html">Geom</a> *&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a geom from the queued list of geoms to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the geom will automatically be dequeued and prepared at the next frame.</p>
<p>The return value is true if the geom is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="aff8d32c6ab9684ac0df1b14173bc0879" name="aff8d32c6ab9684ac0df1b14173bc0879"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8d32c6ab9684ac0df1b14173bc0879">&#9670;&#160;</a></span>dequeue_index_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::dequeue_index_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a buffer from the queued list of data arrays to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the data will automatically be dequeued and prepared at the next frame.</p>
<p>The return value is true if the buffer is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="a877f59c985f9213e7cc6e666322eebbe" name="a877f59c985f9213e7cc6e666322eebbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a877f59c985f9213e7cc6e666322eebbe">&#9670;&#160;</a></span>dequeue_sampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::dequeue_sampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a sampler from the queued list of samplers to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the sampler will automatically be dequeued and prepared at the next frame.</p>
<p>The return value is true if the sampler is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="a541897e01cf3cd0f8fb55b3597c8eeb3" name="a541897e01cf3cd0f8fb55b3597c8eeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541897e01cf3cd0f8fb55b3597c8eeb3">&#9670;&#160;</a></span>dequeue_shader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::dequeue_shader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classShader.html">Shader</a> *&#160;</td>
          <td class="paramname"><em>se</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a shader from the queued list of shaders to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the shader will automatically be dequeued and prepared at the next frame.</p>
<p>The return value is true if the shader is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="ac0e3898509b4b30d463edd780a18d693" name="ac0e3898509b4b30d463edd780a18d693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0e3898509b4b30d463edd780a18d693">&#9670;&#160;</a></span>dequeue_shader_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::dequeue_shader_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a buffer from the queued list of data arrays to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the data will automatically be dequeued and prepared at the next frame.</p>
<p>The return value is true if the buffer is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="aa8955cb8109a28da78f52de756baa1e8" name="aa8955cb8109a28da78f52de756baa1e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8955cb8109a28da78f52de756baa1e8">&#9670;&#160;</a></span>dequeue_texture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::dequeue_texture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTexture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a texture from the queued list of textures to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the texture will automatically be dequeued and prepared at the next frame.</p>
<p>The return value is true if the texture is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="a1e4bdb510823b3ad5359172953879f67" name="a1e4bdb510823b3ad5359172953879f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e4bdb510823b3ad5359172953879f67">&#9670;&#160;</a></span>dequeue_vertex_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::dequeue_vertex_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes a buffer from the queued list of data arrays to be prepared. Normally it is not necessary to call this, unless you change your mind about preparing it at the last minute, since the data will automatically be dequeued and prepared at the next frame.</p>
<p>The return value is true if the buffer is successfully dequeued, false if it had not been queued. </p>

</div>
</div>
<a id="ab5cda370924af2053e2920e42790f83e" name="ab5cda370924af2053e2920e42790f83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cda370924af2053e2920e42790f83e">&#9670;&#160;</a></span>end_frame()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::end_frame </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classThread.html">Thread</a> *&#160;</td>
          <td class="paramname"><em>current_thread</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is called by the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> to indicate that it has finished processing of the frame. </p>

</div>
</div>
<a id="ae994e9bc04c1dd10ef935cce122aacc0" name="ae994e9bc04c1dd10ef935cce122aacc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae994e9bc04c1dd10ef935cce122aacc0">&#9670;&#160;</a></span>enqueue_geom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::enqueue_geom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeom.html">Geom</a> *&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a geom would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="adf09abd6c22be7507612524390a07f91" name="adf09abd6c22be7507612524390a07f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf09abd6c22be7507612524390a07f91">&#9670;&#160;</a></span>enqueue_index_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::enqueue_index_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a buffer would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="a42de2dc2d52a0974865984b17886696b" name="a42de2dc2d52a0974865984b17886696b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42de2dc2d52a0974865984b17886696b">&#9670;&#160;</a></span>enqueue_sampler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::enqueue_sampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a sampler would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="ae89d9f2e64192a1d03ad81524591abf6" name="ae89d9f2e64192a1d03ad81524591abf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae89d9f2e64192a1d03ad81524591abf6">&#9670;&#160;</a></span>enqueue_shader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::enqueue_shader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classShader.html">Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a shader would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="afb7ec2bae9d28c4c0548ec609eeb8e51" name="afb7ec2bae9d28c4c0548ec609eeb8e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb7ec2bae9d28c4c0548ec609eeb8e51">&#9670;&#160;</a></span>enqueue_shader_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::enqueue_shader_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a buffer would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="a45db9601d0aaea6961a93b8e6e228a7a" name="a45db9601d0aaea6961a93b8e6e228a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45db9601d0aaea6961a93b8e6e228a7a">&#9670;&#160;</a></span>enqueue_texture()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::enqueue_texture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTexture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a texture would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="a079c30ee715d902194d78a002f8956d3" name="a079c30ee715d902194d78a002f8956d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a079c30ee715d902194d78a002f8956d3">&#9670;&#160;</a></span>enqueue_vertex_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::enqueue_vertex_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a buffer would like to be put on the list to be prepared when the GSG is next ready to do this (presumably at the next frame). </p>

</div>
</div>
<a id="a9839688f4e1bfa32a48d55a702948f22" name="a9839688f4e1bfa32a48d55a702948f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9839688f4e1bfa32a48d55a702948f22">&#9670;&#160;</a></span>get_num_prepared_geoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_prepared_geoms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of geoms that have already been prepared on this GSG. </p>

</div>
</div>
<a id="af84ab4d05715ff737b28ac11f8932329" name="af84ab4d05715ff737b28ac11f8932329"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af84ab4d05715ff737b28ac11f8932329">&#9670;&#160;</a></span>get_num_prepared_index_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_prepared_index_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of index buffers that have already been prepared on this GSG. </p>

</div>
</div>
<a id="ac691b73e37e4b805b24ff5e6e11ba22b" name="ac691b73e37e4b805b24ff5e6e11ba22b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac691b73e37e4b805b24ff5e6e11ba22b">&#9670;&#160;</a></span>get_num_prepared_samplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_prepared_samplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of samplers that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a2e05737b7c1be108200cbaab6ca38219" name="a2e05737b7c1be108200cbaab6ca38219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e05737b7c1be108200cbaab6ca38219">&#9670;&#160;</a></span>get_num_prepared_shader_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_prepared_shader_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of index buffers that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a2843b80d55a448d3b65aefd0fcabb7e2" name="a2843b80d55a448d3b65aefd0fcabb7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2843b80d55a448d3b65aefd0fcabb7e2">&#9670;&#160;</a></span>get_num_prepared_shaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_prepared_shaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of shaders that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a3ed4062fcfe4fc44554d170eab416c16" name="a3ed4062fcfe4fc44554d170eab416c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed4062fcfe4fc44554d170eab416c16">&#9670;&#160;</a></span>get_num_prepared_textures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_prepared_textures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of textures that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a2ead49c7cf089235d9e8e49e9100c567" name="a2ead49c7cf089235d9e8e49e9100c567"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ead49c7cf089235d9e8e49e9100c567">&#9670;&#160;</a></span>get_num_prepared_vertex_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_prepared_vertex_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of vertex buffers that have already been prepared on this GSG. </p>

</div>
</div>
<a id="a08733a06d2183dbf22acb6467a66768b" name="a08733a06d2183dbf22acb6467a66768b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08733a06d2183dbf22acb6467a66768b">&#9670;&#160;</a></span>get_num_queued_geoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_queued_geoms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of geoms that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a2d4529a94a0633fad3337a269c98b14e" name="a2d4529a94a0633fad3337a269c98b14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4529a94a0633fad3337a269c98b14e">&#9670;&#160;</a></span>get_num_queued_index_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_queued_index_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of index buffers that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a4e8f636d6b1cc1e3c3059a01972c5f81" name="a4e8f636d6b1cc1e3c3059a01972c5f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8f636d6b1cc1e3c3059a01972c5f81">&#9670;&#160;</a></span>get_num_queued_samplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_queued_samplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of samplers that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="af4f6a71dc0d6edd72c7a21ebe1bca785" name="af4f6a71dc0d6edd72c7a21ebe1bca785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f6a71dc0d6edd72c7a21ebe1bca785">&#9670;&#160;</a></span>get_num_queued_shader_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_queued_shader_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of index buffers that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a53551f80a69d1a6a9dbcba3a9187d87f" name="a53551f80a69d1a6a9dbcba3a9187d87f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53551f80a69d1a6a9dbcba3a9187d87f">&#9670;&#160;</a></span>get_num_queued_shaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_queued_shaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of shaders that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a7b2bc29d67f057461567e046d0be1d90" name="a7b2bc29d67f057461567e046d0be1d90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2bc29d67f057461567e046d0be1d90">&#9670;&#160;</a></span>get_num_queued_textures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_queued_textures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of textures that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a46d68396374634d0a6f3027cd54faf46" name="a46d68396374634d0a6f3027cd54faf46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d68396374634d0a6f3027cd54faf46">&#9670;&#160;</a></span>get_num_queued_vertex_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::get_num_queued_vertex_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of vertex buffers that have been enqueued to be prepared on this GSG. </p>

</div>
</div>
<a id="a4bccb7827e030552ed18dd9151ec5754" name="a4bccb7827e030552ed18dd9151ec5754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bccb7827e030552ed18dd9151ec5754">&#9670;&#160;</a></span>is_geom_prepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_geom_prepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeom.html">Geom</a> *&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vertex buffer has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a9419853618c0c691b12fe509eff54435" name="a9419853618c0c691b12fe509eff54435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9419853618c0c691b12fe509eff54435">&#9670;&#160;</a></span>is_geom_queued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_geom_queued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeom.html">Geom</a> *&#160;</td>
          <td class="paramname"><em>geom</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the geom has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="a319ec66d521c211a7b4eb229909813b7" name="a319ec66d521c211a7b4eb229909813b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a319ec66d521c211a7b4eb229909813b7">&#9670;&#160;</a></span>is_index_buffer_prepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_index_buffer_prepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the index buffer has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a9e9ce9afd532179f713985f21e916d3a" name="a9e9ce9afd532179f713985f21e916d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9ce9afd532179f713985f21e916d3a">&#9670;&#160;</a></span>is_index_buffer_queued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_index_buffer_queued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the index buffer has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="a78ab8c5017701a3273400ffa400d6b5a" name="a78ab8c5017701a3273400ffa400d6b5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ab8c5017701a3273400ffa400d6b5a">&#9670;&#160;</a></span>is_sampler_prepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_sampler_prepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the sampler has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a81e61009f472eeb7bfb2ba807180b221" name="a81e61009f472eeb7bfb2ba807180b221"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e61009f472eeb7bfb2ba807180b221">&#9670;&#160;</a></span>is_sampler_queued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_sampler_queued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the sampler has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="aa06e2cc9cf2af3540bb5088ab92a7c58" name="aa06e2cc9cf2af3540bb5088ab92a7c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06e2cc9cf2af3540bb5088ab92a7c58">&#9670;&#160;</a></span>is_shader_buffer_prepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_shader_buffer_prepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the index buffer has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a524e4abd51279265c34df3c2213d6726" name="a524e4abd51279265c34df3c2213d6726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a524e4abd51279265c34df3c2213d6726">&#9670;&#160;</a></span>is_shader_buffer_queued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_shader_buffer_queued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the index buffer has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="acd5cb9dabd93eb67d723c98a634897de" name="acd5cb9dabd93eb67d723c98a634897de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd5cb9dabd93eb67d723c98a634897de">&#9670;&#160;</a></span>is_shader_prepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_shader_prepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classShader.html">Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the shader has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a473b9aad42c05a8d00b3c65c18f6efce" name="a473b9aad42c05a8d00b3c65c18f6efce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a473b9aad42c05a8d00b3c65c18f6efce">&#9670;&#160;</a></span>is_shader_queued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_shader_queued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classShader.html">Shader</a> *&#160;</td>
          <td class="paramname"><em>shader</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the shader has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="a5c1ffea82760bf8132a147435f52d4ca" name="a5c1ffea82760bf8132a147435f52d4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c1ffea82760bf8132a147435f52d4ca">&#9670;&#160;</a></span>is_texture_prepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_texture_prepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTexture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the texture has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="a1f8d89b003463ec85b48a67832f65246" name="a1f8d89b003463ec85b48a67832f65246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8d89b003463ec85b48a67832f65246">&#9670;&#160;</a></span>is_texture_queued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_texture_queued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTexture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the texture has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="ad2e5b057ccd7e849fa18825565ed5939" name="ad2e5b057ccd7e849fa18825565ed5939"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e5b057ccd7e849fa18825565ed5939">&#9670;&#160;</a></span>is_vertex_buffer_prepared()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_vertex_buffer_prepared </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vertex buffer has been prepared on this GSG, false otherwise. </p>

</div>
</div>
<a id="ae9c5184ab1923a62fbd26e50e418406f" name="ae9c5184ab1923a62fbd26e50e418406f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9c5184ab1923a62fbd26e50e418406f">&#9670;&#160;</a></span>is_vertex_buffer_queued()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool PreparedGraphicsObjects::is_vertex_buffer_queued </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the vertex buffer has been queued on this GSG, false otherwise. </p>

</div>
</div>
<a id="aac80f5c15475dff257ea6e25d5b115f2" name="aac80f5c15475dff257ea6e25d5b115f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac80f5c15475dff257ea6e25d5b115f2">&#9670;&#160;</a></span>prepare_geom_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGeomContext.html">GeomContext</a> * PreparedGraphicsObjects::prepare_geom_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeom.html">Geom</a> *&#160;</td>
          <td class="paramname"><em>geom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately creates a new <a class="el" href="classGeomContext.html">GeomContext</a> for the indicated geom and returns it. This assumes that the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new geoms. If this is not necessarily the case, you should use <a class="el" href="classPreparedGraphicsObjects.html#ae994e9bc04c1dd10ef935cce122aacc0">enqueue_geom()</a> instead.</p>
<p>Normally, this function is not called directly. Call <a class="el" href="classGeom.html#a8d0f1d79caa99fcdb4392b5c9ba2b288">Geom::prepare_now()</a> instead.</p>
<p>The <a class="el" href="classGeomContext.html">GeomContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular geom, and will exist as long as the geom is ready to be rendered.</p>
<p>When either the <a class="el" href="classGeom.html">Geom</a> or the <a class="el" href="classPreparedGraphicsObjects.html">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classGeomContext.html">GeomContext</a> will be deleted. </p>

</div>
</div>
<a id="af9bf742de2512a1a0b4acf3e90ca2ccd" name="af9bf742de2512a1a0b4acf3e90ca2ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bf742de2512a1a0b4acf3e90ca2ccd">&#9670;&#160;</a></span>prepare_index_buffer_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexBufferContext.html">IndexBufferContext</a> * PreparedGraphicsObjects::prepare_index_buffer_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeomPrimitive.html">GeomPrimitive</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately creates a new <a class="el" href="classIndexBufferContext.html">IndexBufferContext</a> for the indicated data and returns it. This assumes that the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new datas. If this is not necessarily the case, you should use <a class="el" href="classPreparedGraphicsObjects.html#adf09abd6c22be7507612524390a07f91">enqueue_index_buffer()</a> instead.</p>
<p>Normally, this function is not called directly. Call Data::prepare_now() instead.</p>
<p>The <a class="el" href="classIndexBufferContext.html">IndexBufferContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular data, and will exist as long as the data is ready to be rendered.</p>
<p>When either the Data or the <a class="el" href="classPreparedGraphicsObjects.html">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classIndexBufferContext.html">IndexBufferContext</a> will be deleted. </p>

</div>
</div>
<a id="a48fa5e9fac61516d64cfd383f90c8954" name="a48fa5e9fac61516d64cfd383f90c8954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48fa5e9fac61516d64cfd383f90c8954">&#9670;&#160;</a></span>prepare_sampler_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSamplerContext.html">SamplerContext</a> * PreparedGraphicsObjects::prepare_sampler_now </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;&#160;</td>
          <td class="paramname"><em>sampler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately creates a new <a class="el" href="classSamplerContext.html">SamplerContext</a> for the indicated sampler and returns it. This assumes that the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new samplers. If this is not necessarily the case, you should use <a class="el" href="classPreparedGraphicsObjects.html#a42de2dc2d52a0974865984b17886696b">enqueue_sampler()</a> instead.</p>
<p>Normally, this function is not called directly. Call Sampler::prepare_now() instead.</p>
<p>The <a class="el" href="classSamplerContext.html">SamplerContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular sampler, and will exist as long as the sampler is ready to be rendered.</p>
<p>When either the Sampler or the <a class="el" href="classPreparedGraphicsObjects.html">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classSamplerContext.html">SamplerContext</a> will be deleted. </p>

</div>
</div>
<a id="ae12ac6231b3b0635344d226536aa05a7" name="ae12ac6231b3b0635344d226536aa05a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12ac6231b3b0635344d226536aa05a7">&#9670;&#160;</a></span>prepare_shader_buffer_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBufferContext.html">BufferContext</a> * PreparedGraphicsObjects::prepare_shader_buffer_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classShaderBuffer.html">ShaderBuffer</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately creates a new <a class="el" href="classBufferContext.html">BufferContext</a> for the indicated data and returns it. This assumes that the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new datas. If this is not necessarily the case, you should use <a class="el" href="classPreparedGraphicsObjects.html#afb7ec2bae9d28c4c0548ec609eeb8e51">enqueue_shader_buffer()</a> instead.</p>
<p>Normally, this function is not called directly. Call Data::prepare_now() instead.</p>
<p>The <a class="el" href="classBufferContext.html">BufferContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular data, and will exist as long as the data is ready to be rendered.</p>
<p>When either the Data or the <a class="el" href="classPreparedGraphicsObjects.html">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classBufferContext.html">BufferContext</a> will be deleted. </p>

</div>
</div>
<a id="afa11213aa7b163caadbbe58d3fbe17ef" name="afa11213aa7b163caadbbe58d3fbe17ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa11213aa7b163caadbbe58d3fbe17ef">&#9670;&#160;</a></span>prepare_shader_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classShaderContext.html">ShaderContext</a> * PreparedGraphicsObjects::prepare_shader_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classShader.html">Shader</a> *&#160;</td>
          <td class="paramname"><em>se</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately creates a new <a class="el" href="classShaderContext.html">ShaderContext</a> for the indicated shader and returns it. This assumes that the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new shaders. If this is not necessarily the case, you should use <a class="el" href="classPreparedGraphicsObjects.html#ae89d9f2e64192a1d03ad81524591abf6">enqueue_shader()</a> instead.</p>
<p>Normally, this function is not called directly. Call Shader::prepare_now() instead.</p>
<p>The <a class="el" href="classShaderContext.html">ShaderContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular shader, and will exist as long as the shader is ready to be rendered.</p>
<p>When either the <a class="el" href="classShader.html">Shader</a> or the <a class="el" href="classPreparedGraphicsObjects.html">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classShaderContext.html">ShaderContext</a> will be deleted. </p>

</div>
</div>
<a id="ae704ff16e42ab4959e725c1af7478658" name="ae704ff16e42ab4959e725c1af7478658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae704ff16e42ab4959e725c1af7478658">&#9670;&#160;</a></span>prepare_texture_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTextureContext.html">TextureContext</a> * PreparedGraphicsObjects::prepare_texture_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTexture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>tex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately creates a new <a class="el" href="classTextureContext.html">TextureContext</a> for the indicated texture and returns it. This assumes that the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new textures. If this is not necessarily the case, you should use <a class="el" href="classPreparedGraphicsObjects.html#a45db9601d0aaea6961a93b8e6e228a7a">enqueue_texture()</a> instead.</p>
<p>Normally, this function is not called directly. Call <a class="el" href="classTexture.html#a6b3856662e05f463811735252aaae40f">Texture::prepare_now()</a> instead.</p>
<p>The <a class="el" href="classTextureContext.html">TextureContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular texture, and will exist as long as the texture is ready to be rendered.</p>
<p>When either the <a class="el" href="classTexture.html">Texture</a> or the <a class="el" href="classPreparedGraphicsObjects.html">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classTextureContext.html">TextureContext</a> will be deleted. </p>

</div>
</div>
<a id="afeaff6051a1dd128235fb44dd2ac1c59" name="afeaff6051a1dd128235fb44dd2ac1c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeaff6051a1dd128235fb44dd2ac1c59">&#9670;&#160;</a></span>prepare_vertex_buffer_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVertexBufferContext.html">VertexBufferContext</a> * PreparedGraphicsObjects::prepare_vertex_buffer_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeomVertexArrayData.html">GeomVertexArrayData</a> *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGraphicsStateGuardianBase.html">GraphicsStateGuardianBase</a> *&#160;</td>
          <td class="paramname"><em>gsg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Immediately creates a new <a class="el" href="classVertexBufferContext.html">VertexBufferContext</a> for the indicated data and returns it. This assumes that the <a class="el" href="classGraphicsStateGuardian.html">GraphicsStateGuardian</a> is the currently active rendering context and that it is ready to accept new datas. If this is not necessarily the case, you should use <a class="el" href="classPreparedGraphicsObjects.html#a079c30ee715d902194d78a002f8956d3">enqueue_vertex_buffer()</a> instead.</p>
<p>Normally, this function is not called directly. Call Data::prepare_now() instead.</p>
<p>The <a class="el" href="classVertexBufferContext.html">VertexBufferContext</a> contains all of the pertinent information needed by the GSG to keep track of this one particular data, and will exist as long as the data is ready to be rendered.</p>
<p>When either the Data or the <a class="el" href="classPreparedGraphicsObjects.html">PreparedGraphicsObjects</a> object destructs, the <a class="el" href="classVertexBufferContext.html">VertexBufferContext</a> will be deleted. </p>

</div>
</div>
<a id="a0f00472736ce5eebb4dc2b226e1e6bce" name="a0f00472736ce5eebb4dc2b226e1e6bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f00472736ce5eebb4dc2b226e1e6bce">&#9670;&#160;</a></span>release_all_geoms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::release_all_geoms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all geoms at once. This will force them to be reloaded into geom memory for all GSG's that share this object. Returns the number of geoms released. </p>

</div>
</div>
<a id="a898c6bd1745cb7fb66cd4d7bf504fea4" name="a898c6bd1745cb7fb66cd4d7bf504fea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898c6bd1745cb7fb66cd4d7bf504fea4">&#9670;&#160;</a></span>release_all_index_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::release_all_index_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all datas at once. This will force them to be reloaded into data memory for all GSG's that share this object. Returns the number of datas released. </p>

</div>
</div>
<a id="aba0b983ecc27f47c3ccea5f7781c93bd" name="aba0b983ecc27f47c3ccea5f7781c93bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba0b983ecc27f47c3ccea5f7781c93bd">&#9670;&#160;</a></span>release_all_samplers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::release_all_samplers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all samplers at once. This will force them to be reloaded for all GSG's that share this object. Returns the number of samplers released. </p>

</div>
</div>
<a id="a9c965ce640c2a987edf76bc4192f1123" name="a9c965ce640c2a987edf76bc4192f1123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c965ce640c2a987edf76bc4192f1123">&#9670;&#160;</a></span>release_all_shader_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::release_all_shader_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all datas at once. This will force them to be reloaded into data memory for all GSG's that share this object. Returns the number of datas released. </p>

</div>
</div>
<a id="a76828328f3f682fe752fe6548868108c" name="a76828328f3f682fe752fe6548868108c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76828328f3f682fe752fe6548868108c">&#9670;&#160;</a></span>release_all_shaders()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::release_all_shaders </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all shaders at once. This will force them to be reloaded into shader memory for all GSG's that share this object. Returns the number of shaders released. </p>

</div>
</div>
<a id="a25dbf284d46e9fef6cb667c58dc3537d" name="a25dbf284d46e9fef6cb667c58dc3537d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dbf284d46e9fef6cb667c58dc3537d">&#9670;&#160;</a></span>release_all_textures()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::release_all_textures </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all textures at once. This will force them to be reloaded into texture memory for all GSG's that share this object. Returns the number of textures released. </p>

</div>
</div>
<a id="af70583653a4410fa1b15f1ea56aa1d11" name="af70583653a4410fa1b15f1ea56aa1d11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70583653a4410fa1b15f1ea56aa1d11">&#9670;&#160;</a></span>release_all_vertex_buffers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int PreparedGraphicsObjects::release_all_vertex_buffers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases all datas at once. This will force them to be reloaded into data memory for all GSG's that share this object. Returns the number of datas released. </p>

</div>
</div>
<a id="a30c53457f4c0eb29752970b309d8b86c" name="a30c53457f4c0eb29752970b309d8b86c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c53457f4c0eb29752970b309d8b86c">&#9670;&#160;</a></span>release_geom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_geom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classGeomContext.html">GeomContext</a> *&#160;</td>
          <td class="paramname"><em>gc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a geom context, created by a previous call to prepare_geom(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release geoms&ndash;this prevents conflicts from threading or multiple GSG's sharing geoms (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_geom is called). </p>

</div>
</div>
<a id="ac550c095aa65420418a2bf9c4b8c075e" name="ac550c095aa65420418a2bf9c4b8c075e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac550c095aa65420418a2bf9c4b8c075e">&#9670;&#160;</a></span>release_index_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_index_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIndexBufferContext.html">IndexBufferContext</a> *&#160;</td>
          <td class="paramname"><em>ibc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a data context, created by a previous call to prepare_index_buffer(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release datas&ndash;this prevents conflicts from threading or multiple GSG's sharing datas (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_index_buffer is called). </p>

</div>
</div>
<a id="a937039d2724d0af1c7f6f78c3bc38af3" name="a937039d2724d0af1c7f6f78c3bc38af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a937039d2724d0af1c7f6f78c3bc38af3">&#9670;&#160;</a></span>release_sampler() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_sampler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSamplerState.html">SamplerState</a> &amp;&#160;</td>
          <td class="paramname"><em>sampler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a sampler if it has already been prepared, or removes it from the preparation queue. </p>

</div>
</div>
<a id="a178fa14ef996798fdec0f1afd122c771" name="a178fa14ef996798fdec0f1afd122c771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a178fa14ef996798fdec0f1afd122c771">&#9670;&#160;</a></span>release_sampler() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_sampler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSamplerContext.html">SamplerContext</a> *&#160;</td>
          <td class="paramname"><em>sc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a sampler context, created by a previous call to prepare_sampler(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release samplers. </p>

</div>
</div>
<a id="a98c153ead0efb71422b793e54c90f4cc" name="a98c153ead0efb71422b793e54c90f4cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c153ead0efb71422b793e54c90f4cc">&#9670;&#160;</a></span>release_shader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_shader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classShaderContext.html">ShaderContext</a> *&#160;</td>
          <td class="paramname"><em>sc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a shader context, created by a previous call to prepare_shader(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release shaders&ndash;this prevents conflicts from threading or multiple GSG's sharing shaders (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_shader is called). </p>

</div>
</div>
<a id="a6880461c92f69406e37e4257d3f24c88" name="a6880461c92f69406e37e4257d3f24c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6880461c92f69406e37e4257d3f24c88">&#9670;&#160;</a></span>release_shader_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_shader_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBufferContext.html">BufferContext</a> *&#160;</td>
          <td class="paramname"><em>bc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a data context, created by a previous call to prepare_shader_buffer(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release datas&ndash;this prevents conflicts from threading or multiple GSG's sharing datas (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_shader_buffer is called). </p>

</div>
</div>
<a id="a25769173593d65f4ac03882a41a7a551" name="a25769173593d65f4ac03882a41a7a551"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25769173593d65f4ac03882a41a7a551">&#9670;&#160;</a></span>release_texture() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_texture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTexture.html">Texture</a> *&#160;</td>
          <td class="paramname"><em>tex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Releases a texture if it has already been prepared, or removes it from the preparation queue. </p>

</div>
</div>
<a id="af34c2d5663ee60380dc3b4d11c65452d" name="af34c2d5663ee60380dc3b4d11c65452d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34c2d5663ee60380dc3b4d11c65452d">&#9670;&#160;</a></span>release_texture() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_texture </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTextureContext.html">TextureContext</a> *&#160;</td>
          <td class="paramname"><em>tc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a texture context, created by a previous call to prepare_texture(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release textures&ndash;this prevents conflicts from threading or multiple GSG's sharing textures (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_texture is called). </p>

</div>
</div>
<a id="ae66e2cf8ebb5525ddd2a453639382600" name="ae66e2cf8ebb5525ddd2a453639382600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae66e2cf8ebb5525ddd2a453639382600">&#9670;&#160;</a></span>release_vertex_buffer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::release_vertex_buffer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVertexBufferContext.html">VertexBufferContext</a> *&#160;</td>
          <td class="paramname"><em>vbc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that a data context, created by a previous call to prepare_vertex_buffer(), is no longer needed. The driver resources will not be freed until some GSG calls update(), indicating it is at a stage where it is ready to release datas&ndash;this prevents conflicts from threading or multiple GSG's sharing datas (we have no way of knowing which graphics context is currently active, or what state it's in, at the time release_vertex_buffer is called). </p>

</div>
</div>
<a id="aa13d5058568db17f29dc3e031e4289e3" name="aa13d5058568db17f29dc3e031e4289e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa13d5058568db17f29dc3e031e4289e3">&#9670;&#160;</a></span>set_graphics_memory_limit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::set_graphics_memory_limit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets an artificial cap on graphics memory that will be imposed on this GSG.</p>
<p>This limits the total amount of graphics memory, including texture memory and vertex buffer memory, that will be consumed by the GSG, regardless of whether the hardware claims to provide more graphics memory than this. It is useful to put a ceiling on graphics memory consumed, since some drivers seem to allow the application to consume more memory than the hardware can realistically support. </p>

</div>
</div>
<a id="abc6967e94f5246f34ee2ef4206db067d" name="abc6967e94f5246f34ee2ef4206db067d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc6967e94f5246f34ee2ef4206db067d">&#9670;&#160;</a></span>show_graphics_memory_lru()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::show_graphics_memory_lru </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to the indicated ostream a report of how the various textures and vertex buffers are allocated in the LRU. </p>

</div>
</div>
<a id="a4715494b08a64b0087e573e7feb96be0" name="a4715494b08a64b0087e573e7feb96be0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4715494b08a64b0087e573e7feb96be0">&#9670;&#160;</a></span>show_residency_trackers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void PreparedGraphicsObjects::show_residency_trackers </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes to the indicated ostream a report of how the various textures and vertex buffers are allocated in the LRU. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>panda/src/gobj/<a class="el" href="preparedGraphicsObjects_8h_source.html">preparedGraphicsObjects.h</a></li>
<li>panda/src/gobj/<a class="el" href="preparedGraphicsObjects_8cxx_source.html">preparedGraphicsObjects.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
