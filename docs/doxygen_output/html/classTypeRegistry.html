<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D C++ Architecture: TypeRegistry Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Panda3D C++ Architecture
   </div>
   <div id="projectbrief">API reference for Panda3D&#39;s C++ codebase.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTypeRegistry-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">TypeRegistry Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="typeRegistry_8h_source.html">typeRegistry.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TypeRegistry:</div>
<div class="dyncontent">
<div class="center"><img src="classTypeRegistry__inherit__graph.png" border="0" usemap="#aTypeRegistry_inherit__map" alt="Inheritance graph"/></div>
<map name="aTypeRegistry_inherit__map" id="aTypeRegistry_inherit__map">
<area shape="rect" title=" " alt="" coords="5,78,147,103"/>
<area shape="rect" href="classMemoryBase.html" title=" " alt="" coords="15,5,137,30"/>
<area shape="poly" title=" " alt="" coords="79,46,79,78,73,78,73,46"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for TypeRegistry:</div>
<div class="dyncontent">
<div class="center"><img src="classTypeRegistry__coll__graph.png" border="0" usemap="#aTypeRegistry_coll__map" alt="Collaboration graph"/></div>
<map name="aTypeRegistry_coll__map" id="aTypeRegistry_coll__map">
<area shape="rect" title=" " alt="" coords="5,78,147,103"/>
<area shape="rect" href="classMemoryBase.html" title=" " alt="" coords="15,5,137,30"/>
<area shape="poly" title=" " alt="" coords="79,46,79,78,73,78,73,46"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adc66909016aed6b9604c4631242321fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#adc66909016aed6b9604c4631242321fd">register_type</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> &amp;type_handle, const std::string &amp;name)</td></tr>
<tr class="separator:adc66909016aed6b9604c4631242321fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9189b18a15371963fc342f5905ccfbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#aa9189b18a15371963fc342f5905ccfbc">record_derivation</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> child, <a class="el" href="classTypeHandle.html">TypeHandle</a> parent)</td></tr>
<tr class="separator:aa9189b18a15371963fc342f5905ccfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366507708e64cc8d78d16b525b105af6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#a366507708e64cc8d78d16b525b105af6">record_alternate_name</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> type, const std::string &amp;name)</td></tr>
<tr class="separator:a366507708e64cc8d78d16b525b105af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace84a2c2729c7c85c6456ba84b6f46d3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#ace84a2c2729c7c85c6456ba84b6f46d3">find_type</a> (const std::string &amp;name) const</td></tr>
<tr class="separator:ace84a2c2729c7c85c6456ba84b6f46d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bbed45cb5c8aec781d7e3387c211a04"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#a5bbed45cb5c8aec781d7e3387c211a04">find_type_by_id</a> (int id) const</td></tr>
<tr class="separator:a5bbed45cb5c8aec781d7e3387c211a04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac44a9f4c43ecd8c47346ca42b1d91050"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#ac44a9f4c43ecd8c47346ca42b1d91050">get_name</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> type, <a class="el" href="classTypedObject.html">TypedObject</a> *object) const</td></tr>
<tr class="separator:ac44a9f4c43ecd8c47346ca42b1d91050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab190379d29ba3973367a8f8212b6bfca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#ab190379d29ba3973367a8f8212b6bfca">is_derived_from</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> child, <a class="el" href="classTypeHandle.html">TypeHandle</a> base, <a class="el" href="classTypedObject.html">TypedObject</a> *child_object)</td></tr>
<tr class="separator:ab190379d29ba3973367a8f8212b6bfca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96abdb41203f2cf778f61a8d786d1502"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#a96abdb41203f2cf778f61a8d786d1502">get_num_typehandles</a> ()</td></tr>
<tr class="separator:a96abdb41203f2cf778f61a8d786d1502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa626b0a8d0700438506204c1dcf476df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#aa626b0a8d0700438506204c1dcf476df">get_typehandle</a> (int n)</td></tr>
<tr class="separator:aa626b0a8d0700438506204c1dcf476df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1c15a61bfa53709b2179d8b9d1d105f"><td class="memItemLeft" align="right" valign="top"><a id="ad1c15a61bfa53709b2179d8b9d1d105f" name="ad1c15a61bfa53709b2179d8b9d1d105f"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_SEQ</b> (get_typehandles, <a class="el" href="classTypeRegistry.html#a96abdb41203f2cf778f61a8d786d1502">get_num_typehandles</a>, <a class="el" href="classTypeRegistry.html#aa626b0a8d0700438506204c1dcf476df">get_typehandle</a>)</td></tr>
<tr class="separator:ad1c15a61bfa53709b2179d8b9d1d105f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1248b65dc7edada0fafe9478b5f5f7a8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#a1248b65dc7edada0fafe9478b5f5f7a8">get_num_root_classes</a> ()</td></tr>
<tr class="separator:a1248b65dc7edada0fafe9478b5f5f7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf6d602946323200048cb0a8561e413"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#aacf6d602946323200048cb0a8561e413">get_root_class</a> (int n)</td></tr>
<tr class="separator:aacf6d602946323200048cb0a8561e413"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1a4a721c8e0ef8c6b2f42ab3270173"><td class="memItemLeft" align="right" valign="top"><a id="a8e1a4a721c8e0ef8c6b2f42ab3270173" name="a8e1a4a721c8e0ef8c6b2f42ab3270173"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_SEQ</b> (get_root_classes, <a class="el" href="classTypeRegistry.html#a1248b65dc7edada0fafe9478b5f5f7a8">get_num_root_classes</a>, <a class="el" href="classTypeRegistry.html#aacf6d602946323200048cb0a8561e413">get_root_class</a>)</td></tr>
<tr class="separator:a8e1a4a721c8e0ef8c6b2f42ab3270173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe4eff14c795c519150e23d1550b31b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#adbe4eff14c795c519150e23d1550b31b">get_num_parent_classes</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> child, <a class="el" href="classTypedObject.html">TypedObject</a> *child_object) const</td></tr>
<tr class="separator:adbe4eff14c795c519150e23d1550b31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a19ff8000a7d9ad2af3e0efbe22df0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#a6a19ff8000a7d9ad2af3e0efbe22df0f">get_parent_class</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> child, int index) const</td></tr>
<tr class="separator:a6a19ff8000a7d9ad2af3e0efbe22df0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5d4ba02a7b20ead2c391612fccb4959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#ab5d4ba02a7b20ead2c391612fccb4959">get_num_child_classes</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> child, <a class="el" href="classTypedObject.html">TypedObject</a> *child_object) const</td></tr>
<tr class="separator:ab5d4ba02a7b20ead2c391612fccb4959"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf45c3ec5f980d92da5eedcab3677b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#aacf45c3ec5f980d92da5eedcab3677b3">get_child_class</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> child, int index) const</td></tr>
<tr class="separator:aacf45c3ec5f980d92da5eedcab3677b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0caca4497cc7b0efb16271e5ebdda60"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#ad0caca4497cc7b0efb16271e5ebdda60">get_parent_towards</a> (<a class="el" href="classTypeHandle.html">TypeHandle</a> child, <a class="el" href="classTypeHandle.html">TypeHandle</a> base, <a class="el" href="classTypedObject.html">TypedObject</a> *child_object)</td></tr>
<tr class="separator:ad0caca4497cc7b0efb16271e5ebdda60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735a201d5dddfd0395f0cf194f79932a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#a735a201d5dddfd0395f0cf194f79932a">write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a735a201d5dddfd0395f0cf194f79932a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a71c08ac72ee9edb242add2027708e5"><td class="memItemLeft" align="right" valign="top"><a id="a6a71c08ac72ee9edb242add2027708e5" name="a6a71c08ac72ee9edb242add2027708e5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_SEQ_PROPERTY</b> (typehandles, <a class="el" href="classTypeRegistry.html#a96abdb41203f2cf778f61a8d786d1502">get_num_typehandles</a>, <a class="el" href="classTypeRegistry.html#aa626b0a8d0700438506204c1dcf476df">get_typehandle</a>)</td></tr>
<tr class="separator:a6a71c08ac72ee9edb242add2027708e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3d024126ca21552a10f21717945d98"><td class="memItemLeft" align="right" valign="top"><a id="a9d3d024126ca21552a10f21717945d98" name="a9d3d024126ca21552a10f21717945d98"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_SEQ_PROPERTY</b> (root_classes, <a class="el" href="classTypeRegistry.html#a1248b65dc7edada0fafe9478b5f5f7a8">get_num_root_classes</a>, <a class="el" href="classTypeRegistry.html#aacf6d602946323200048cb0a8561e413">get_root_class</a>)</td></tr>
<tr class="separator:a9d3d024126ca21552a10f21717945d98"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aec460e877ea369b393a7a8e804ac91b7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTypeRegistry.html#aec460e877ea369b393a7a8e804ac91b7">reregister_types</a> ()</td></tr>
<tr class="separator:aec460e877ea369b393a7a8e804ac91b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb091ea02efb3152e91a9a714246e2c"><td class="memItemLeft" align="right" valign="top"><a id="a3bb091ea02efb3152e91a9a714246e2c" name="a3bb091ea02efb3152e91a9a714246e2c"></a>
static INLINE <a class="el" href="classTypeRegistry.html">TypeRegistry</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>ptr</b> ()</td></tr>
<tr class="separator:a3bb091ea02efb3152e91a9a714246e2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a5dc2688ed49a0fbe3e5bf71edabf86f8"><td class="memItemLeft" align="right" valign="top"><a id="a5dc2688ed49a0fbe3e5bf71edabf86f8" name="a5dc2688ed49a0fbe3e5bf71edabf86f8"></a>
PUBLISHED&#160;</td><td class="memItemRight" valign="bottom">: <a class="el" href="classTypeHandle.html">TypeHandle</a> <a class="el" href="register__type_8h.html#a794f6c2c22ea49d39ab910fa69acc2a9">register_dynamic_type</a>(const std::string &amp;name)</td></tr>
<tr class="separator:a5dc2688ed49a0fbe3e5bf71edabf86f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classMemoryBase"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classMemoryBase')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classMemoryBase.html">MemoryBase</a></td></tr>
<tr class="memitem:aaa0812a01210684812d2df819684c997 inherit pub_attribs_classMemoryBase"><td class="memItemLeft" align="right" valign="top">
&#160;</td><td class="memItemRight" valign="bottom"><b>ALLOC_MEMORY_BASE</b></td></tr>
<tr class="separator:aaa0812a01210684812d2df819684c997 inherit pub_attribs_classMemoryBase"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="friends" name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a83de7f4c05a998a092d43a26f9dd5e6d"><td class="memItemLeft" align="right" valign="top"><a id="a83de7f4c05a998a092d43a26f9dd5e6d" name="a83de7f4c05a998a092d43a26f9dd5e6d"></a>
class&#160;</td><td class="memItemRight" valign="bottom"><b>TypeHandle</b></td></tr>
<tr class="separator:a83de7f4c05a998a092d43a26f9dd5e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The <a class="el" href="classTypeRegistry.html">TypeRegistry</a> class maintains all the assigned TypeHandles in a given system. There should be only one <a class="el" href="classTypeRegistry.html">TypeRegistry</a> class during the lifetime of the application. It will be created on the local heap initially, and it should be migrated to shared memory as soon as shared memory becomes available. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="ace84a2c2729c7c85c6456ba84b6f46d3" name="ace84a2c2729c7c85c6456ba84b6f46d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace84a2c2729c7c85c6456ba84b6f46d3">&#9670;&#160;</a></span>find_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeHandle.html">TypeHandle</a> TypeRegistry::find_type </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a previously-registered type of the given name. Returns its <a class="el" href="classTypeHandle.html">TypeHandle</a> if it exists, or TypeHandle::none() if there is no such type. </p>

</div>
</div>
<a id="a5bbed45cb5c8aec781d7e3387c211a04" name="a5bbed45cb5c8aec781d7e3387c211a04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bbed45cb5c8aec781d7e3387c211a04">&#9670;&#160;</a></span>find_type_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeHandle.html">TypeHandle</a> TypeRegistry::find_type_by_id </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Looks for a previously-registered type with the given id number (as returned by TypeHandle::get_index()). Returns its <a class="el" href="classTypeHandle.html">TypeHandle</a> if it exists, or TypeHandle::none() if there is no such type. </p>

</div>
</div>
<a id="aacf45c3ec5f980d92da5eedcab3677b3" name="aacf45c3ec5f980d92da5eedcab3677b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf45c3ec5f980d92da5eedcab3677b3">&#9670;&#160;</a></span>get_child_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeHandle.html">TypeHandle</a> TypeRegistry::get_child_class </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the nth child class of this type. The index should be in the range 0 &lt;= index &lt; <a class="el" href="classTypeRegistry.html#ab5d4ba02a7b20ead2c391612fccb4959">get_num_child_classes()</a>. </p>

</div>
</div>
<a id="ac44a9f4c43ecd8c47346ca42b1d91050" name="ac44a9f4c43ecd8c47346ca42b1d91050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac44a9f4c43ecd8c47346ca42b1d91050">&#9670;&#160;</a></span>get_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string TypeRegistry::get_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypedObject.html">TypedObject</a> *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the name of the indicated type.</p>
<p>The "object" pointer is an optional pointer to the <a class="el" href="classTypedObject.html">TypedObject</a> class that owns this <a class="el" href="classTypeHandle.html">TypeHandle</a>. It is only used in case the <a class="el" href="classTypeHandle.html">TypeHandle</a> is inadvertantly undefined. </p>

</div>
</div>
<a id="ab5d4ba02a7b20ead2c391612fccb4959" name="ab5d4ba02a7b20ead2c391612fccb4959"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5d4ba02a7b20ead2c391612fccb4959">&#9670;&#160;</a></span>get_num_child_classes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TypeRegistry::get_num_child_classes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypedObject.html">TypedObject</a> *&#160;</td>
          <td class="paramname"><em>child_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of child classes that the indicated type is known to have. This may then be used to index into <a class="el" href="classTypeRegistry.html#aacf45c3ec5f980d92da5eedcab3677b3">get_child_class()</a>.</p>
<p>The "object" pointer is an optional pointer to the <a class="el" href="classTypedObject.html">TypedObject</a> class that owns this <a class="el" href="classTypeHandle.html">TypeHandle</a>. It is only used in case the <a class="el" href="classTypeHandle.html">TypeHandle</a> is inadvertantly undefined. </p>

</div>
</div>
<a id="adbe4eff14c795c519150e23d1550b31b" name="adbe4eff14c795c519150e23d1550b31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe4eff14c795c519150e23d1550b31b">&#9670;&#160;</a></span>get_num_parent_classes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TypeRegistry::get_num_parent_classes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypedObject.html">TypedObject</a> *&#160;</td>
          <td class="paramname"><em>child_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of parent classes that the indicated type is known to have. This may then be used to index into <a class="el" href="classTypeRegistry.html#a6a19ff8000a7d9ad2af3e0efbe22df0f">get_parent_class()</a>. The result will be 0 if this class does not inherit from any other classes, 1 if normal, single inheritance is in effect, or greater than one if multiple inheritance is in effect.</p>
<p>The "object" pointer is an optional pointer to the <a class="el" href="classTypedObject.html">TypedObject</a> class that owns this <a class="el" href="classTypeHandle.html">TypeHandle</a>. It is only used in case the <a class="el" href="classTypeHandle.html">TypeHandle</a> is inadvertantly undefined. </p>

</div>
</div>
<a id="a1248b65dc7edada0fafe9478b5f5f7a8" name="a1248b65dc7edada0fafe9478b5f5f7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1248b65dc7edada0fafe9478b5f5f7a8">&#9670;&#160;</a></span>get_num_root_classes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TypeRegistry::get_num_root_classes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of root classes&ndash;that is, classes that do not inherit from any other classes&ndash;known in the system. </p>

</div>
</div>
<a id="a96abdb41203f2cf778f61a8d786d1502" name="a96abdb41203f2cf778f61a8d786d1502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96abdb41203f2cf778f61a8d786d1502">&#9670;&#160;</a></span>get_num_typehandles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int TypeRegistry::get_num_typehandles </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the total number of unique TypeHandles in the system. </p>

</div>
</div>
<a id="a6a19ff8000a7d9ad2af3e0efbe22df0f" name="a6a19ff8000a7d9ad2af3e0efbe22df0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a19ff8000a7d9ad2af3e0efbe22df0f">&#9670;&#160;</a></span>get_parent_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeHandle.html">TypeHandle</a> TypeRegistry::get_parent_class </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the nth parent class of this type. The index should be in the range 0 &lt;= index &lt; <a class="el" href="classTypeRegistry.html#adbe4eff14c795c519150e23d1550b31b">get_num_parent_classes()</a>. </p>

</div>
</div>
<a id="ad0caca4497cc7b0efb16271e5ebdda60" name="ad0caca4497cc7b0efb16271e5ebdda60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0caca4497cc7b0efb16271e5ebdda60">&#9670;&#160;</a></span>get_parent_towards()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeHandle.html">TypeHandle</a> TypeRegistry::get_parent_towards </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypedObject.html">TypedObject</a> *&#160;</td>
          <td class="paramname"><em>child_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the parent of the indicated child class that is in a direct line of inheritance to the indicated ancestor class. This is useful in the presence of multiple inheritance to try to determine what properties an unknown type may have.</p>
<p>The "object" pointer is an optional pointer to the <a class="el" href="classTypedObject.html">TypedObject</a> class that owns this <a class="el" href="classTypeHandle.html">TypeHandle</a>. It is only used in case the <a class="el" href="classTypeHandle.html">TypeHandle</a> is inadvertantly undefined. </p>

</div>
</div>
<a id="aacf6d602946323200048cb0a8561e413" name="aacf6d602946323200048cb0a8561e413"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacf6d602946323200048cb0a8561e413">&#9670;&#160;</a></span>get_root_class()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeHandle.html">TypeHandle</a> TypeRegistry::get_root_class </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the nth root class in the system. See <a class="el" href="classTypeRegistry.html#a1248b65dc7edada0fafe9478b5f5f7a8">get_num_root_classes()</a>. </p>

</div>
</div>
<a id="aa626b0a8d0700438506204c1dcf476df" name="aa626b0a8d0700438506204c1dcf476df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa626b0a8d0700438506204c1dcf476df">&#9670;&#160;</a></span>get_typehandle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeHandle.html">TypeHandle</a> TypeRegistry::get_typehandle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the nth <a class="el" href="classTypeHandle.html">TypeHandle</a> in the system. See <a class="el" href="classTypeRegistry.html#a96abdb41203f2cf778f61a8d786d1502">get_num_typehandles()</a>. </p>

</div>
</div>
<a id="ab190379d29ba3973367a8f8212b6bfca" name="ab190379d29ba3973367a8f8212b6bfca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab190379d29ba3973367a8f8212b6bfca">&#9670;&#160;</a></span>is_derived_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeRegistry::is_derived_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypedObject.html">TypedObject</a> *&#160;</td>
          <td class="paramname"><em>child_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the first type is derived from the second type, false otherwise.</p>
<p>The "child_object" pointer is an optional pointer to the <a class="el" href="classTypedObject.html">TypedObject</a> class that owns the child <a class="el" href="classTypeHandle.html">TypeHandle</a>. It is only used in case the <a class="el" href="classTypeHandle.html">TypeHandle</a> is inadvertently undefined.</p>
<p>This function definition follows the definitions for look_up() and freshen_derivations() just to maximize the chance the the compiler will be able to inline the above functions. Yeah, a compiler shouldn't care, but there's a big different between "shouldn't" and "doesn't". </p>

</div>
</div>
<a id="a366507708e64cc8d78d16b525b105af6" name="a366507708e64cc8d78d16b525b105af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366507708e64cc8d78d16b525b105af6">&#9670;&#160;</a></span>record_alternate_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeRegistry::record_alternate_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates an alternate name for the same type. This is particularly useful when a type has changed names, since the type is stored in a Bam file by name; setting the original name as the alternate will allow the type to be correctly read from old Bam files. </p>

</div>
</div>
<a id="aa9189b18a15371963fc342f5905ccfbc" name="aa9189b18a15371963fc342f5905ccfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9189b18a15371963fc342f5905ccfbc">&#9670;&#160;</a></span>record_derivation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeRegistry::record_derivation </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td>
          <td class="paramname"><em>parent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records that the type referenced by child inherits directly from the type referenced by parent. In the event of multiple inheritance, this should be called once for each parent class. </p>

</div>
</div>
<a id="adc66909016aed6b9604c4631242321fd" name="adc66909016aed6b9604c4631242321fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc66909016aed6b9604c4631242321fd">&#9670;&#160;</a></span>register_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool TypeRegistry::register_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypeHandle.html">TypeHandle</a> &amp;&#160;</td>
          <td class="paramname"><em>type_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new Type of the given name and assigns a unique value to the type_handle. All type names must be unique. If the type name has already been used, the supplied type_handle value must match the name's assigned type_handle or an error is triggered. Returns true if the name wasn't defined before, false if it was. </p>

</div>
</div>
<a id="aec460e877ea369b393a7a8e804ac91b7" name="aec460e877ea369b393a7a8e804ac91b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec460e877ea369b393a7a8e804ac91b7">&#9670;&#160;</a></span>reregister_types()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TypeRegistry::reregister_types </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Walks through the <a class="el" href="classTypeRegistry.html">TypeRegistry</a> tree and makes sure that each type that was previously registered is <em>still</em> registered. This seems to get broken in certain circumstances when compiled against libc5&ndash;it is as if the static initializer stomps on the _type_handle values of each class after they've been registered. </p>

</div>
</div>
<a id="a735a201d5dddfd0395f0cf194f79932a" name="a735a201d5dddfd0395f0cf194f79932a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735a201d5dddfd0395f0cf194f79932a">&#9670;&#160;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TypeRegistry::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Makes an attempt to format the entire <a class="el" href="classTypeRegistry.html">TypeRegistry</a> in a nice way that shows the derivation tree as intelligently as possible. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>dtool/src/dtoolbase/<a class="el" href="typeRegistry_8h_source.html">typeRegistry.h</a></li>
<li>dtool/src/dtoolbase/<a class="el" href="typeRegistry_8cxx_source.html">typeRegistry.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
