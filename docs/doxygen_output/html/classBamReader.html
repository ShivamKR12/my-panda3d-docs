<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.7"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Panda3D C++ Architecture: BamReader Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Panda3D C++ Architecture
   </div>
   <div id="projectbrief">API reference for Panda3D&#39;s C++ codebase.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.7 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classBamReader-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">BamReader Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="bamReader_8h_source.html">bamReader.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BamReader:</div>
<div class="dyncontent">
<div class="center"><img src="classBamReader__inherit__graph.png" border="0" usemap="#aBamReader_inherit__map" alt="Inheritance graph"/></div>
<map name="aBamReader_inherit__map" id="aBamReader_inherit__map">
<area shape="rect" title=" " alt="" coords="5,898691,117,898716"/>
<area shape="rect" href="classBamEnums.html" title=" " alt="" coords="10,5,112,898643"/>
<area shape="poly" title=" " alt="" coords="64,898659,64,898691,58,898691,58,898659"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for BamReader:</div>
<div class="dyncontent">
<div class="center"><img src="classBamReader__coll__graph.png" border="0" usemap="#aBamReader_coll__map" alt="Collaboration graph"/></div>
<map name="aBamReader_coll__map" id="aBamReader_coll__map">
<area shape="rect" title=" " alt="" coords="51,321823,162,321847"/>
<area shape="poly" title=" " alt="" coords="104,321807,115,313018,128,306742,141,302977,147,302037,156,301722,165,302041,171,302984,180,306756,187,313039,189,321835,187,330632,180,336916,171,340687,165,341630,156,341948,147,341632,141,340690,128,336923,115,330642,104,321848,109,321848,120,330642,133,336923,146,340690,153,341632,156,341943,160,341630,165,340687,175,336916,181,330632,184,321835,181,313039,175,306756,165,302984,160,302041,156,301727,153,302037,146,302977,133,306742,120,313018,109,321807"/>
<area shape="rect" href="classBamEnums.html" title=" " alt="" coords="5,79,107,214556"/>
<area shape="poly" title=" " alt="" coords="84,214571,109,321822,104,321822,79,214571"/>
<area shape="rect" href="classFactory.html" title=" " alt="" coords="130,107305,302,107330"/>
<area shape="poly" title=" " alt="" coords="219,107345,109,321822,104,321822,213,107345"/>
<area shape="rect" href="classFactoryBase.html" title=" " alt="" coords="150,5,282,30"/>
<area shape="poly" title=" " alt="" coords="219,46,219,107305,213,107305,213,46"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader_1_1AuxData.html">AuxData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-types" name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac80cc609f9cba0039ff71d9ca556c8a3"><td class="memItemLeft" align="right" valign="top"><a id="ac80cc609f9cba0039ff71d9ca556c8a3" name="ac80cc609f9cba0039ff71d9ca556c8a3"></a>
typedef <a class="el" href="classFactory.html">Factory</a>&lt; <a class="el" href="classTypedWritable.html">TypedWritable</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>WritableFactory</b></td></tr>
<tr class="separator:ac80cc609f9cba0039ff71d9ca556c8a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4f9f1e2be8f6a2023a78de3dac38ef3"><td class="memItemLeft" align="right" valign="top"><a id="ab4f9f1e2be8f6a2023a78de3dac38ef3" name="ab4f9f1e2be8f6a2023a78de3dac38ef3"></a>
typedef <a class="el" href="classTypedWritable.html">TypedWritable</a> *(*&#160;</td><td class="memItemRight" valign="bottom"><b>ChangeThisFunc</b>) (<a class="el" href="classTypedWritable.html">TypedWritable</a> *object, <a class="el" href="classBamReader.html">BamReader</a> *manager)</td></tr>
<tr class="separator:ab4f9f1e2be8f6a2023a78de3dac38ef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269492afc99d8e72bacd1fbdc03b4b75"><td class="memItemLeft" align="right" valign="top"><a id="a269492afc99d8e72bacd1fbdc03b4b75" name="a269492afc99d8e72bacd1fbdc03b4b75"></a>
typedef PT() <a class="el" href="classTypedWritableReferenceCount.html">TypedWritableReferenceCount</a>(*&#160;</td><td class="memItemRight" valign="bottom"><b>ChangeThisRefFunc</b>) (<a class="el" href="classTypedWritableReferenceCount.html">TypedWritableReferenceCount</a> *object, <a class="el" href="classBamReader.html">BamReader</a> *manager)</td></tr>
<tr class="separator:a269492afc99d8e72bacd1fbdc03b4b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac9a16586acc8b40ab61f2f0998e4aa11"><td class="memItemLeft" align="right" valign="top"><a id="ac9a16586acc8b40ab61f2f0998e4aa11" name="ac9a16586acc8b40ab61f2f0998e4aa11"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>set_source</b> (<a class="el" href="classDatagramGenerator.html">DatagramGenerator</a> *source)</td></tr>
<tr class="separator:ac9a16586acc8b40ab61f2f0998e4aa11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed930d0e459e3d7c98b09a1a2d97421e"><td class="memItemLeft" align="right" valign="top"><a id="aed930d0e459e3d7c98b09a1a2d97421e" name="aed930d0e459e3d7c98b09a1a2d97421e"></a>
INLINE <a class="el" href="classDatagramGenerator.html">DatagramGenerator</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_source</b> ()</td></tr>
<tr class="separator:aed930d0e459e3d7c98b09a1a2d97421e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93a91392b652d4096988fd6c093ee128"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a93a91392b652d4096988fd6c093ee128">init</a> ()</td></tr>
<tr class="separator:a93a91392b652d4096988fd6c093ee128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97cb720e14628af2131871369039b986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a97cb720e14628af2131871369039b986">set_aux_data</a> (<a class="el" href="classTypedWritable.html">TypedWritable</a> *obj, const std::string &amp;name, <a class="el" href="classBamReader_1_1AuxData.html">AuxData</a> *data)</td></tr>
<tr class="separator:a97cb720e14628af2131871369039b986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad712ff1b19f81915b7619978ce485254"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBamReader_1_1AuxData.html">AuxData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#ad712ff1b19f81915b7619978ce485254">get_aux_data</a> (<a class="el" href="classTypedWritable.html">TypedWritable</a> *obj, const std::string &amp;name) const</td></tr>
<tr class="separator:ad712ff1b19f81915b7619978ce485254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25735d10416d98f50f94e547757f488e"><td class="memItemLeft" align="right" valign="top"><a id="a25735d10416d98f50f94e547757f488e" name="a25735d10416d98f50f94e547757f488e"></a>
INLINE const <a class="el" href="classFilename.html">Filename</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_filename</b> () const</td></tr>
<tr class="separator:a25735d10416d98f50f94e547757f488e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5726fd892248c4438140dbb910e6c675"><td class="memItemLeft" align="right" valign="top"><a id="a5726fd892248c4438140dbb910e6c675" name="a5726fd892248c4438140dbb910e6c675"></a>
INLINE const <a class="el" href="classLoaderOptions.html">LoaderOptions</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>get_loader_options</b> () const</td></tr>
<tr class="separator:a5726fd892248c4438140dbb910e6c675"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbc3c9b78c3b99bf49cbe6218be81d5"><td class="memItemLeft" align="right" valign="top"><a id="a1cbc3c9b78c3b99bf49cbe6218be81d5" name="a1cbc3c9b78c3b99bf49cbe6218be81d5"></a>
INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>set_loader_options</b> (const <a class="el" href="classLoaderOptions.html">LoaderOptions</a> &amp;options)</td></tr>
<tr class="separator:a1cbc3c9b78c3b99bf49cbe6218be81d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2745e61d4d3750aae692e72bc02fa3f"><td class="memItemLeft" align="right" valign="top">BLOCKING <a class="el" href="classTypedWritable.html">TypedWritable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#aa2745e61d4d3750aae692e72bc02fa3f">read_object</a> ()</td></tr>
<tr class="separator:aa2745e61d4d3750aae692e72bc02fa3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782349fe0080d024c2013d8bf647df8d"><td class="memItemLeft" align="right" valign="top">BLOCKING bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a782349fe0080d024c2013d8bf647df8d">read_object</a> (<a class="el" href="classTypedWritable.html">TypedWritable</a> *&amp;ptr, <a class="el" href="classReferenceCount.html">ReferenceCount</a> *&amp;ref_ptr)</td></tr>
<tr class="separator:a782349fe0080d024c2013d8bf647df8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545c638867488b68cf59d9633bcd207a"><td class="memItemLeft" align="right" valign="top"><a id="a545c638867488b68cf59d9633bcd207a" name="a545c638867488b68cf59d9633bcd207a"></a>
INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_eof</b> () const</td></tr>
<tr class="separator:a545c638867488b68cf59d9633bcd207a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79364fc8c51fdf559ea8c8c8aea0fb41"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a79364fc8c51fdf559ea8c8c8aea0fb41">resolve</a> ()</td></tr>
<tr class="separator:a79364fc8c51fdf559ea8c8c8aea0fb41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca396cd4d55d805e00e66b111fc9ddb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a0ca396cd4d55d805e00e66b111fc9ddb">change_pointer</a> (const <a class="el" href="classTypedWritable.html">TypedWritable</a> *orig_pointer, const <a class="el" href="classTypedWritable.html">TypedWritable</a> *new_pointer)</td></tr>
<tr class="separator:a0ca396cd4d55d805e00e66b111fc9ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b77162aa483de7e408e52595e133d8"><td class="memItemLeft" align="right" valign="top"><a id="a20b77162aa483de7e408e52595e133d8" name="a20b77162aa483de7e408e52595e133d8"></a>
INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>get_file_major_ver</b> () const</td></tr>
<tr class="separator:a20b77162aa483de7e408e52595e133d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac82f2fee188d011640afde7c7bea6d83"><td class="memItemLeft" align="right" valign="top"><a id="ac82f2fee188d011640afde7c7bea6d83" name="ac82f2fee188d011640afde7c7bea6d83"></a>
INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>get_file_minor_ver</b> () const</td></tr>
<tr class="separator:ac82f2fee188d011640afde7c7bea6d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84acc308dacff478d9f10be3d4d36d4f"><td class="memItemLeft" align="right" valign="top"><a id="a84acc308dacff478d9f10be3d4d36d4f" name="a84acc308dacff478d9f10be3d4d36d4f"></a>
INLINE BamEndian&#160;</td><td class="memItemRight" valign="bottom"><b>get_file_endian</b> () const</td></tr>
<tr class="separator:a84acc308dacff478d9f10be3d4d36d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8d4d92e498cf6c373daf3cdd06ab7e9"><td class="memItemLeft" align="right" valign="top"><a id="ad8d4d92e498cf6c373daf3cdd06ab7e9" name="ad8d4d92e498cf6c373daf3cdd06ab7e9"></a>
INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><b>get_file_stdfloat_double</b> () const</td></tr>
<tr class="separator:ad8d4d92e498cf6c373daf3cdd06ab7e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade75e6cd5942f133be3393bf8c4d2e6"><td class="memItemLeft" align="right" valign="top"><a id="aade75e6cd5942f133be3393bf8c4d2e6" name="aade75e6cd5942f133be3393bf8c4d2e6"></a>
INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>get_current_major_ver</b> () const</td></tr>
<tr class="separator:aade75e6cd5942f133be3393bf8c4d2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39d06c3ce742134e930c52b92d4a2e1f"><td class="memItemLeft" align="right" valign="top"><a id="a39d06c3ce742134e930c52b92d4a2e1f" name="a39d06c3ce742134e930c52b92d4a2e1f"></a>
INLINE int&#160;</td><td class="memItemRight" valign="bottom"><b>get_current_minor_ver</b> () const</td></tr>
<tr class="separator:a39d06c3ce742134e930c52b92d4a2e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824c8786f71ab6700f3075bd8ebd9f26"><td class="memItemLeft" align="right" valign="top"><a id="a824c8786f71ab6700f3075bd8ebd9f26" name="a824c8786f71ab6700f3075bd8ebd9f26"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PY_EXTENSION</b> (PyObject *get_file_version() const)</td></tr>
<tr class="separator:a824c8786f71ab6700f3075bd8ebd9f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1838800c721b946b7eef36c5b8d4702e"><td class="memItemLeft" align="right" valign="top"><a id="a1838800c721b946b7eef36c5b8d4702e" name="a1838800c721b946b7eef36c5b8d4702e"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_PROPERTY</b> (filename, get_filename)</td></tr>
<tr class="separator:a1838800c721b946b7eef36c5b8d4702e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70c0780b6b4278744cdfb9b944356f9"><td class="memItemLeft" align="right" valign="top"><a id="ab70c0780b6b4278744cdfb9b944356f9" name="ab70c0780b6b4278744cdfb9b944356f9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_PROPERTY</b> (loader_options, get_loader_options, set_loader_options)</td></tr>
<tr class="separator:ab70c0780b6b4278744cdfb9b944356f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d820d0f4a5af391dc1b0b391c9b2852"><td class="memItemLeft" align="right" valign="top"><a id="a7d820d0f4a5af391dc1b0b391c9b2852" name="a7d820d0f4a5af391dc1b0b391c9b2852"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>PY_MAKE_PROPERTY</b> (file_version, get_file_version)</td></tr>
<tr class="separator:a7d820d0f4a5af391dc1b0b391c9b2852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f205b2b5a64487f69efff0ae45fe13"><td class="memItemLeft" align="right" valign="top"><a id="ac8f205b2b5a64487f69efff0ae45fe13" name="ac8f205b2b5a64487f69efff0ae45fe13"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_PROPERTY</b> (file_endian, get_file_endian)</td></tr>
<tr class="separator:ac8f205b2b5a64487f69efff0ae45fe13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c35f4ec20534aa91d3babb5e12d5b88"><td class="memItemLeft" align="right" valign="top"><a id="a5c35f4ec20534aa91d3babb5e12d5b88" name="a5c35f4ec20534aa91d3babb5e12d5b88"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>MAKE_PROPERTY</b> (file_stdfloat_double, get_file_stdfloat_double)</td></tr>
<tr class="separator:a5c35f4ec20534aa91d3babb5e12d5b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ecc0609d9c6de514145777b3336435"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#ac0ecc0609d9c6de514145777b3336435">read_pointer</a> (<a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;scan)</td></tr>
<tr class="separator:ac0ecc0609d9c6de514145777b3336435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10ea3ed8500e58d80ff4c58e4f1771cb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a10ea3ed8500e58d80ff4c58e4f1771cb">read_pointers</a> (<a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;scan, int count)</td></tr>
<tr class="separator:a10ea3ed8500e58d80ff4c58e4f1771cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63c44ae63b95a3ddcce8b42ff80ccec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a63c44ae63b95a3ddcce8b42ff80ccec7">skip_pointer</a> (<a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;scan)</td></tr>
<tr class="separator:a63c44ae63b95a3ddcce8b42ff80ccec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244a3bc4eed4b5d8e8c8f7a717f57578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a244a3bc4eed4b5d8e8c8f7a717f57578">read_file_data</a> (<a class="el" href="classSubfileInfo.html">SubfileInfo</a> &amp;info)</td></tr>
<tr class="separator:a244a3bc4eed4b5d8e8c8f7a717f57578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae63d90cd5d2c87fe3159f6b5d6d9fe10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#ae63d90cd5d2c87fe3159f6b5d6d9fe10">read_cdata</a> (<a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;scan, <a class="el" href="structPipelineCyclerTrivialImpl.html">PipelineCyclerBase</a> &amp;cycler)</td></tr>
<tr class="separator:ae63d90cd5d2c87fe3159f6b5d6d9fe10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d758a0beb430ea1adbdd8e0782be55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#af8d758a0beb430ea1adbdd8e0782be55">read_cdata</a> (<a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;scan, <a class="el" href="structPipelineCyclerTrivialImpl.html">PipelineCyclerBase</a> &amp;cycler, void *extra_data)</td></tr>
<tr class="separator:af8d758a0beb430ea1adbdd8e0782be55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd83f808114527e3b7b0a40cab0ca761"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#abd83f808114527e3b7b0a40cab0ca761">set_int_tag</a> (const std::string &amp;tag, int value)</td></tr>
<tr class="separator:abd83f808114527e3b7b0a40cab0ca761"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2eed6914e03be304c6cf14ea291d97e6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a2eed6914e03be304c6cf14ea291d97e6">get_int_tag</a> (const std::string &amp;tag) const</td></tr>
<tr class="separator:a2eed6914e03be304c6cf14ea291d97e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aa3682ea4e1d6fb08f88fb3f65104d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a8aa3682ea4e1d6fb08f88fb3f65104d0">set_aux_tag</a> (const std::string &amp;tag, <a class="el" href="classBamReaderAuxData.html">BamReaderAuxData</a> *value)</td></tr>
<tr class="separator:a8aa3682ea4e1d6fb08f88fb3f65104d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731a71d6c4028513e2685a5f633692ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBamReaderAuxData.html">BamReaderAuxData</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a731a71d6c4028513e2685a5f633692ab">get_aux_tag</a> (const std::string &amp;tag) const</td></tr>
<tr class="separator:a731a71d6c4028513e2685a5f633692ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c2e8dc5a794a4263139116b5b8dcb2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a0c2e8dc5a794a4263139116b5b8dcb2d">register_finalize</a> (<a class="el" href="classTypedWritable.html">TypedWritable</a> *whom)</td></tr>
<tr class="separator:a0c2e8dc5a794a4263139116b5b8dcb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa694b5968c0fa549f26b8919451ac230"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#aa694b5968c0fa549f26b8919451ac230">register_change_this</a> (ChangeThisFunc func, <a class="el" href="classTypedWritable.html">TypedWritable</a> *whom)</td></tr>
<tr class="separator:aa694b5968c0fa549f26b8919451ac230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7ffdbd971c5882615e3e908f3f3fa4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#adb7ffdbd971c5882615e3e908f3f3fa4">register_change_this</a> (ChangeThisRefFunc func, <a class="el" href="classTypedWritableReferenceCount.html">TypedWritableReferenceCount</a> *whom)</td></tr>
<tr class="separator:adb7ffdbd971c5882615e3e908f3f3fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a786911fd5b8d98eed701a3bb6e2b3a19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a786911fd5b8d98eed701a3bb6e2b3a19">finalize_now</a> (<a class="el" href="classTypedWritable.html">TypedWritable</a> *whom)</td></tr>
<tr class="separator:a786911fd5b8d98eed701a3bb6e2b3a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9efece8c0f1619065ec377d4b597889e"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a9efece8c0f1619065ec377d4b597889e">get_pta</a> (<a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;scan)</td></tr>
<tr class="separator:a9efece8c0f1619065ec377d4b597889e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ecebbcf5c5058f8660d6d5cada23ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a40ecebbcf5c5058f8660d6d5cada23ea">register_pta</a> (void *ptr)</td></tr>
<tr class="separator:a40ecebbcf5c5058f8660d6d5cada23ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c90778c24386544356506d4a022188e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTypeHandle.html">TypeHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#a0c90778c24386544356506d4a022188e">read_handle</a> (<a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;scan)</td></tr>
<tr class="separator:a0c90778c24386544356506d4a022188e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b6e9c9eefb27c332de7cc9c5d601a4"><td class="memItemLeft" align="right" valign="top"><a id="a29b6e9c9eefb27c332de7cc9c5d601a4" name="a29b6e9c9eefb27c332de7cc9c5d601a4"></a>
INLINE const <a class="el" href="classFileReference.html">FileReference</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_file</b> ()</td></tr>
<tr class="separator:a29b6e9c9eefb27c332de7cc9c5d601a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52f6bd738fb3b0f2d83047902c9ef996"><td class="memItemLeft" align="right" valign="top"><a id="a52f6bd738fb3b0f2d83047902c9ef996" name="a52f6bd738fb3b0f2d83047902c9ef996"></a>
INLINE <a class="el" href="classVirtualFile.html">VirtualFile</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_vfile</b> ()</td></tr>
<tr class="separator:a52f6bd738fb3b0f2d83047902c9ef996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0712ecabd6d56cbd5e0308e9a86da5c"><td class="memItemLeft" align="right" valign="top"><a id="aa0712ecabd6d56cbd5e0308e9a86da5c" name="aa0712ecabd6d56cbd5e0308e9a86da5c"></a>
INLINE std::streampos&#160;</td><td class="memItemRight" valign="bottom"><b>get_file_pos</b> ()</td></tr>
<tr class="separator:aa0712ecabd6d56cbd5e0308e9a86da5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a48e1b9e593aa82177ec468264653eeee"><td class="memItemLeft" align="right" valign="top"><a id="a48e1b9e593aa82177ec468264653eeee" name="a48e1b9e593aa82177ec468264653eeee"></a>
static INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>register_factory</b> (<a class="el" href="classTypeHandle.html">TypeHandle</a> type, WritableFactory::CreateFunc *func, void *user_data=nullptr)</td></tr>
<tr class="separator:a48e1b9e593aa82177ec468264653eeee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4b7d434a0cd59c1a2ebdaf45c63a21"><td class="memItemLeft" align="right" valign="top"><a id="abf4b7d434a0cd59c1a2ebdaf45c63a21" name="abf4b7d434a0cd59c1a2ebdaf45c63a21"></a>
static INLINE <a class="el" href="classFactory.html">WritableFactory</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>get_factory</b> ()</td></tr>
<tr class="separator:abf4b7d434a0cd59c1a2ebdaf45c63a21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-attribs" name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a46ae36e069039292d8ca7b5dd1b9f7ab"><td class="memItemLeft" align="right" valign="top"><a id="a46ae36e069039292d8ca7b5dd1b9f7ab" name="a46ae36e069039292d8ca7b5dd1b9f7ab"></a>
PUBLISHED&#160;</td><td class="memItemRight" valign="bottom">: explicit <a class="el" href="classBamReader.html">BamReader</a>(<a class="el" href="classDatagramGenerator.html">DatagramGenerator</a> *source = nullptr)</td></tr>
<tr class="separator:a46ae36e069039292d8ca7b5dd1b9f7ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f38b166282cec9b61461247f5a819e2"><td class="memItemLeft" align="right" valign="top"><a id="a9f38b166282cec9b61461247f5a819e2" name="a9f38b166282cec9b61461247f5a819e2"></a>
PUBLISHED&#160;</td><td class="memItemRight" valign="bottom">: MAKE_PROPERTY(source</td></tr>
<tr class="separator:a9f38b166282cec9b61461247f5a819e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaeb4c88288086cab914e577ece368c6"><td class="memItemLeft" align="right" valign="top"><a id="abaeb4c88288086cab914e577ece368c6" name="abaeb4c88288086cab914e577ece368c6"></a>
PUBLISHED&#160;</td><td class="memItemRight" valign="bottom"><b>get_source</b></td></tr>
<tr class="separator:abaeb4c88288086cab914e577ece368c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d0044dde4a13b80d0e78e53814b894"><td class="memItemLeft" align="right" valign="top">PUBLISHED&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBamReader.html#ae7d0044dde4a13b80d0e78e53814b894">set_source</a></td></tr>
<tr class="separator:ae7d0044dde4a13b80d0e78e53814b894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b18dd424c5948354e63ccd39ccec337"><td class="memItemLeft" align="right" valign="top"><a id="a0b18dd424c5948354e63ccd39ccec337" name="a0b18dd424c5948354e63ccd39ccec337"></a>
PUBLISHED&#160;</td><td class="memItemRight" valign="bottom">: PY_EXTENSION(static void register_factory(<a class="el" href="classTypeHandle.html">TypeHandle</a> handle</td></tr>
<tr class="separator:a0b18dd424c5948354e63ccd39ccec337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11bb0f08bcc3db08501921db56187bb4"><td class="memItemLeft" align="right" valign="top"><a id="a11bb0f08bcc3db08501921db56187bb4" name="a11bb0f08bcc3db08501921db56187bb4"></a>
PUBLISHED PyObject *&#160;</td><td class="memItemRight" valign="bottom"><b>func</b></td></tr>
<tr class="separator:a11bb0f08bcc3db08501921db56187bb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a65f92a0a99124e5a959b4ce7a61f62b1"><td class="memItemLeft" align="right" valign="top"><a id="a65f92a0a99124e5a959b4ce7a61f62b1" name="a65f92a0a99124e5a959b4ce7a61f62b1"></a>
static <a class="el" href="classBamReader.html">BamReader</a> *const&#160;</td><td class="memItemRight" valign="bottom"><b>Null</b> = nullptr</td></tr>
<tr class="separator:a65f92a0a99124e5a959b4ce7a61f62b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceedd00f1ab3499c6da974d8527bbb26"><td class="memItemLeft" align="right" valign="top"><a id="aceedd00f1ab3499c6da974d8527bbb26" name="aceedd00f1ab3499c6da974d8527bbb26"></a>
static <a class="el" href="classFactory.html">WritableFactory</a> *const&#160;</td><td class="memItemRight" valign="bottom"><b>NullFactory</b> = nullptr</td></tr>
<tr class="separator:aceedd00f1ab3499c6da974d8527bbb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the fundamental interface for extracting binary objects from a Bam file, as generated by a <a class="el" href="classBamWriter.html">BamWriter</a>.</p>
<p>A Bam file can be thought of as a linear collection of objects. Each object is an instance of a class that inherits, directly or indirectly, from <a class="el" href="classTypedWritable.html">TypedWritable</a>. The objects may include pointers to other objects within the Bam file; the <a class="el" href="classBamReader.html">BamReader</a> automatically manages these (with help from code within each class) and restores the pointers correctly.</p>
<p>This is the abstract interface and does not specifically deal with disk files, but rather with a <a class="el" href="classDatagramGenerator.html">DatagramGenerator</a> of some kind, which is simply a linear source of Datagrams. It is probably from a disk file, but it might conceivably be streamed directly from a network or some such nonsense.</p>
<p>Bam files are most often used to store scene graphs or subgraphs, and by convention they are given filenames ending in the extension ".bam" when they are used for this purpose. However, a Bam file may store any arbitrary list of <a class="el" href="classTypedWritable.html">TypedWritable</a> objects; in this more general usage, they are given filenames ending in ".boo" to differentiate them from the more common scene graph files.</p>
<p>See also <a class="el" href="classBamFile.html">BamFile</a>, which defines a higher-level interface to read and write Bam files on disk. </p>
</div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a0ca396cd4d55d805e00e66b111fc9ddb" name="a0ca396cd4d55d805e00e66b111fc9ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca396cd4d55d805e00e66b111fc9ddb">&#9670;&#160;</a></span>change_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BamReader::change_pointer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTypedWritable.html">TypedWritable</a> *&#160;</td>
          <td class="paramname"><em>orig_pointer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTypedWritable.html">TypedWritable</a> *&#160;</td>
          <td class="paramname"><em>new_pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Indicates that an object recently read from the bam stream should be replaced with a new object. Any future occurrences of the original object in the stream will henceforth return the new object instead.</p>
<p>The return value is true if the replacement was successfully made, or false if the object was not read from the stream (or if change_pointer had already been called on it). </p>

</div>
</div>
<a id="a786911fd5b8d98eed701a3bb6e2b3a19" name="a786911fd5b8d98eed701a3bb6e2b3a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786911fd5b8d98eed701a3bb6e2b3a19">&#9670;&#160;</a></span>finalize_now()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::finalize_now </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypedWritable.html">TypedWritable</a> *&#160;</td>
          <td class="paramname"><em>whom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forces the finalization of a particular object. This may be called by any of the objects during finalization, to guarantee finalization ordering where it is important. </p>

</div>
</div>
<a id="ad712ff1b19f81915b7619978ce485254" name="ad712ff1b19f81915b7619978ce485254"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad712ff1b19f81915b7619978ce485254">&#9670;&#160;</a></span>get_aux_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBamReader_1_1AuxData.html">BamReader::AuxData</a> * BamReader::get_aux_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypedWritable.html">TypedWritable</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the pointer previously associated with the bam reader by a previous call to <a class="el" href="classBamReader.html#a97cb720e14628af2131871369039b986">set_aux_data()</a>, or NULL if data with the indicated key has not been set. </p>

</div>
</div>
<a id="a731a71d6c4028513e2685a5f633692ab" name="a731a71d6c4028513e2685a5f633692ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731a71d6c4028513e2685a5f633692ab">&#9670;&#160;</a></span>get_aux_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBamReaderAuxData.html">BamReaderAuxData</a> * BamReader::get_aux_tag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value previously set via <a class="el" href="classBamReader.html#a8aa3682ea4e1d6fb08f88fb3f65104d0">set_aux_tag()</a>. It is an error if no value has been set. </p>

</div>
</div>
<a id="a2eed6914e03be304c6cf14ea291d97e6" name="a2eed6914e03be304c6cf14ea291d97e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2eed6914e03be304c6cf14ea291d97e6">&#9670;&#160;</a></span>get_int_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int BamReader::get_int_tag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value previously set via <a class="el" href="classBamReader.html#abd83f808114527e3b7b0a40cab0ca761">set_int_tag()</a>. It is an error if no value has been set. </p>

</div>
</div>
<a id="a9efece8c0f1619065ec377d4b597889e" name="a9efece8c0f1619065ec377d4b597889e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9efece8c0f1619065ec377d4b597889e">&#9670;&#160;</a></span>get_pta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * BamReader::get_pta </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function works in conjection with <a class="el" href="classBamReader.html#a40ecebbcf5c5058f8660d6d5cada23ea">register_pta()</a>, below, to read a <a class="el" href="classPointerToArray.html">PointerToArray</a> (PTA) from the Bam file, and unify references to the same PTA.</p>
<p>The first time <a class="el" href="classBamReader.html#a9efece8c0f1619065ec377d4b597889e">get_pta()</a> encounters a particular PTA, it will return NULL. This is the indication that the caller should then read in the data associated with the PTA, and subsequently call <a class="el" href="classBamReader.html#a40ecebbcf5c5058f8660d6d5cada23ea">register_pta()</a> with the address of the filled-in array.</p>
<p>The next time (and all subsequent times) that <a class="el" href="classBamReader.html#a9efece8c0f1619065ec377d4b597889e">get_pta()</a> encounters this same PTA, it will return the pointer that was passed with <a class="el" href="classBamReader.html#a40ecebbcf5c5058f8660d6d5cada23ea">register_pta()</a>.</p>
<p>Also see the READ_PTA() macro, which consolidates all the work that must be done to read a PTA. </p>

</div>
</div>
<a id="a93a91392b652d4096988fd6c093ee128" name="a93a91392b652d4096988fd6c093ee128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93a91392b652d4096988fd6c093ee128">&#9670;&#160;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BamReader::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the <a class="el" href="classBamReader.html">BamReader</a> prior to reading any objects from its source. This includes reading the Bam header.</p>
<p>This returns true if the <a class="el" href="classBamReader.html">BamReader</a> successfully initialized, false otherwise. </p>

</div>
</div>
<a id="ae63d90cd5d2c87fe3159f6b5d6d9fe10" name="ae63d90cd5d2c87fe3159f6b5d6d9fe10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae63d90cd5d2c87fe3159f6b5d6d9fe10">&#9670;&#160;</a></span>read_cdata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::read_cdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPipelineCyclerTrivialImpl.html">PipelineCyclerBase</a> &amp;&#160;</td>
          <td class="paramname"><em>cycler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads in the indicated <a class="el" href="classCycleData.html">CycleData</a> object. This should be used by classes that store some or all of their data within a <a class="el" href="classCycleData.html">CycleData</a> subclass, in support of pipelining. This will call the virtual <a class="el" href="classCycleData.html#ab97b8929015ca1250aa7a3ae59da30b8">CycleData::fillin()</a> method to do the actual reading. </p>

</div>
</div>
<a id="af8d758a0beb430ea1adbdd8e0782be55" name="af8d758a0beb430ea1adbdd8e0782be55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d758a0beb430ea1adbdd8e0782be55">&#9670;&#160;</a></span>read_cdata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::read_cdata </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structPipelineCyclerTrivialImpl.html">PipelineCyclerBase</a> &amp;&#160;</td>
          <td class="paramname"><em>cycler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>extra_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This flavor of read_cdata allows passing an additional parameter to cdata-&gt;fillin(). </p>

</div>
</div>
<a id="a244a3bc4eed4b5d8e8c8f7a717f57578" name="a244a3bc4eed4b5d8e8c8f7a717f57578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244a3bc4eed4b5d8e8c8f7a717f57578">&#9670;&#160;</a></span>read_file_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::read_file_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSubfileInfo.html">SubfileInfo</a> &amp;&#160;</td>
          <td class="paramname"><em>info</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a block of auxiliary file data from the Bam file. This can be a block of arbitrary size, and it is assumed it may be quite large. Rather than reading the entire block into memory, a file reference is returned to locate the block on disk. The data must have been written by a matching call to write_file_data(). </p>

</div>
</div>
<a id="a0c90778c24386544356506d4a022188e" name="a0c90778c24386544356506d4a022188e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c90778c24386544356506d4a022188e">&#9670;&#160;</a></span>read_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypeHandle.html">TypeHandle</a> BamReader::read_handle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a <a class="el" href="classTypeHandle.html">TypeHandle</a> out of the <a class="el" href="classDatagram.html">Datagram</a>. </p>

</div>
</div>
<a id="aa2745e61d4d3750aae692e72bc02fa3f" name="aa2745e61d4d3750aae692e72bc02fa3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2745e61d4d3750aae692e72bc02fa3f">&#9670;&#160;</a></span>read_object() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTypedWritable.html">TypedWritable</a> * BamReader::read_object </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a single object from the Bam file. If the object type is known, a new object of the appropriate type is created and returned; otherwise, NULL is returned. NULL is also returned when the end of the file is reached. is_eof() may be called to differentiate between these two cases.</p>
<p>This may be called repeatedly to extract out all the objects in the Bam file, but typically (especially for scene graph files, indicated with the .bam extension), only one object is retrieved directly from the Bam file: the root of the scene graph. The remaining objects will all be retrieved recursively by the first object.</p>
<p>Note that the object returned may not yet be complete. In particular, some of its pointers may not be filled in; you must call <a class="el" href="classBamReader.html#a79364fc8c51fdf559ea8c8c8aea0fb41">resolve()</a> to fill in all the available pointers before you can safely use any objects returned by <a class="el" href="classBamReader.html#aa2745e61d4d3750aae692e72bc02fa3f">read_object()</a>.</p>
<p>This flavor of <a class="el" href="classBamReader.html#aa2745e61d4d3750aae692e72bc02fa3f">read_object()</a> requires the caller to know what type of object it has received in order to properly manage the reference counts. </p>

</div>
</div>
<a id="a782349fe0080d024c2013d8bf647df8d" name="a782349fe0080d024c2013d8bf647df8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782349fe0080d024c2013d8bf647df8d">&#9670;&#160;</a></span>read_object() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BamReader::read_object </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypedWritable.html">TypedWritable</a> *&amp;&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classReferenceCount.html">ReferenceCount</a> *&amp;&#160;</td>
          <td class="paramname"><em>ref_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a single object from the Bam file.</p>
<p>This flavor of <a class="el" href="classBamReader.html#aa2745e61d4d3750aae692e72bc02fa3f">read_object()</a> returns both a <a class="el" href="classTypedWritable.html">TypedWritable</a> and a <a class="el" href="classReferenceCount.html">ReferenceCount</a> pointer to the same object, so the reference count may be tracked reliably, without having to know precisely what type of object we have. </p><dl class="section return"><dt>Returns</dt><dd>true on success, or false on failure. </dd></dl>

</div>
</div>
<a id="ac0ecc0609d9c6de514145777b3336435" name="ac0ecc0609d9c6de514145777b3336435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0ecc0609d9c6de514145777b3336435">&#9670;&#160;</a></span>read_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BamReader::read_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The interface for reading a pointer to another object from a Bam file. Objects reading themselves from a Bam file should call this when they expect to read a pointer to some other object. This function reads whatever is stored in the bam file to represent the pointer, and advances the datagram iterator accordingly.</p>
<p>Rather than returning a pointer immediately, this function reads the internal pointer information from the datagram and queues up the request. The pointer itself may not be available until later (it may be a pointer to an object that appears later in the Bam file). Later, when all pointers are available, the complete_pointers() callback function will be called with an array of actual pointers, one for each time <a class="el" href="classBamReader.html#ac0ecc0609d9c6de514145777b3336435">read_pointer()</a> was called. It is then the calling object's responsibility to store these pointers in the object properly.</p>
<p>We don't know what the final pointer will be yet, but we do know whether it was NULL, so this method returns true if the pointer is non-NULL, false if NULL. </p>

</div>
</div>
<a id="a10ea3ed8500e58d80ff4c58e4f1771cb" name="a10ea3ed8500e58d80ff4c58e4f1771cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10ea3ed8500e58d80ff4c58e4f1771cb">&#9670;&#160;</a></span>read_pointers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::read_pointers </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A convenience function to read a contiguous list of pointers. This is equivalent to calling <a class="el" href="classBamReader.html#ac0ecc0609d9c6de514145777b3336435">read_pointer()</a> count times. </p>

</div>
</div>
<a id="aa694b5968c0fa549f26b8919451ac230" name="aa694b5968c0fa549f26b8919451ac230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa694b5968c0fa549f26b8919451ac230">&#9670;&#160;</a></span>register_change_this() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::register_change_this </td>
          <td>(</td>
          <td class="paramtype">ChangeThisFunc&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypedWritable.html">TypedWritable</a> *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by an object reading itself from the bam file to indicate that the object pointer that will be returned is temporary, and will eventually need to be replaced with another pointer.</p>
<p>The supplied function pointer will later be called on the object, immediately after complete_pointers() is called; it should return the new and final pointer.</p>
<p>We use a static function pointer instead of a virtual function (as in finalize()), to allow the function to destruct the old pointer if necessary. (It is invalid to destruct the this pointer within a virtual function.) </p>

</div>
</div>
<a id="adb7ffdbd971c5882615e3e908f3f3fa4" name="adb7ffdbd971c5882615e3e908f3f3fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7ffdbd971c5882615e3e908f3f3fa4">&#9670;&#160;</a></span>register_change_this() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::register_change_this </td>
          <td>(</td>
          <td class="paramtype">ChangeThisRefFunc&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTypedWritableReferenceCount.html">TypedWritableReferenceCount</a> *&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Called by an object reading itself from the bam file to indicate that the object pointer that will be returned is temporary, and will eventually need to be replaced with another pointer.</p>
<p>The supplied function pointer will later be called on the object, immediately after complete_pointers() is called; it should return the new and final pointer.</p>
<p>We use a static function pointer instead of a virtual function (as in finalize()), to allow the function to destruct the old pointer if necessary. (It is invalid to destruct the this pointer within a virtual function.) </p>

</div>
</div>
<a id="a0c2e8dc5a794a4263139116b5b8dcb2d" name="a0c2e8dc5a794a4263139116b5b8dcb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c2e8dc5a794a4263139116b5b8dcb2d">&#9670;&#160;</a></span>register_finalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::register_finalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypedWritable.html">TypedWritable</a> *&#160;</td>
          <td class="paramname"><em>whom</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should be called by an object reading itself from the Bam file to indicate that this particular object would like to receive the finalize() callback when all the objects and pointers in the Bam file are completely read.</p>
<p>This provides a hook for objects that need to do any additional finalization work after all of their related pointers are guaranteed to be filled in. </p>

</div>
</div>
<a id="a40ecebbcf5c5058f8660d6d5cada23ea" name="a40ecebbcf5c5058f8660d6d5cada23ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ecebbcf5c5058f8660d6d5cada23ea">&#9670;&#160;</a></span>register_pta()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::register_pta </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The second part of read_pta(), this should be called with the pointer to the array that was read in after read_pta() returned NULL. This associates the pointer with the ID that was previously read, so that future calls to read_pta() will return the same pointer.</p>
<p>Also see the READ_PTA() macro, which consolidates all the work that must be done to read a PTA. </p>

</div>
</div>
<a id="a79364fc8c51fdf559ea8c8c8aea0fb41" name="a79364fc8c51fdf559ea8c8c8aea0fb41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79364fc8c51fdf559ea8c8c8aea0fb41">&#9670;&#160;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool BamReader::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This may be called at any time during processing of the Bam file to resolve all the known pointers so far. It is usually called at the end of the processing, after all objects have been read, which is generally the best time to call it.</p>
<p>This must be called at least once after reading a particular object via <a class="el" href="classBamReader.html#aa2745e61d4d3750aae692e72bc02fa3f">read_object()</a> in order to validate that object.</p>
<p>The return value is true if all objects have been resolved, or false if some objects are still outstanding (in which case you will need to call <a class="el" href="classBamReader.html#a79364fc8c51fdf559ea8c8c8aea0fb41">resolve()</a> again later). </p>

</div>
</div>
<a id="a97cb720e14628af2131871369039b986" name="a97cb720e14628af2131871369039b986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97cb720e14628af2131871369039b986">&#9670;&#160;</a></span>set_aux_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::set_aux_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTypedWritable.html">TypedWritable</a> *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBamReader_1_1AuxData.html">BamReader::AuxData</a> *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Associates an arbitrary block of data with the indicated object (or NULL), and the indicated name.</p>
<p>This is intended to provide a place for temporary storage for objects reading themselves from the bam file. To use it, inherit from <a class="el" href="classBamReader_1_1AuxData.html">BamReader::AuxData</a> and store whatever data you like there. Then associate your <a class="el" href="classBamReader_1_1AuxData.html">AuxData</a> with the object as it is being read with <a class="el" href="classBamReader.html#a97cb720e14628af2131871369039b986">set_aux_data()</a>. You may later set the aux data to NULL to remove it; or it will automatically be removed (and deleted) after finalize() is called for the object in question.</p>
<p>If the <a class="el" href="classTypedWritable.html">TypedWritable</a> pointer is NULL, the the aux data is stored globally for the <a class="el" href="classBamReader.html">BamReader</a> in general. This pointer is available to any bam objects, and will not be automatically removed until the <a class="el" href="classBamReader.html">BamReader</a> itself destructs.</p>
<p>In either case, the name is just an arbitrary user-defined key. If there is already a data pointer stored for the obj/name pair, that data pointer will be replaced (and deleted). </p>

</div>
</div>
<a id="a8aa3682ea4e1d6fb08f88fb3f65104d0" name="a8aa3682ea4e1d6fb08f88fb3f65104d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aa3682ea4e1d6fb08f88fb3f65104d0">&#9670;&#160;</a></span>set_aux_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::set_aux_tag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBamReaderAuxData.html">BamReaderAuxData</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the creating object to store a temporary data value on the <a class="el" href="classBamReader.html">BamReader</a>. This method may be called during an object's fillin() method; it will associate a newly-allocated <a class="el" href="classBamReaderAuxData.html">BamReaderAuxData</a> construct with an arbitrary string key (which is in turn associated with the calling object only). Later, in the complete_pointers() method, the same object may query this data again via <a class="el" href="classBamReader.html#a731a71d6c4028513e2685a5f633692ab">get_aux_tag()</a>.</p>
<p>The <a class="el" href="classBamReader.html">BamReader</a> will maintain the reference count on the <a class="el" href="classBamReaderAuxData.html">BamReaderAuxData</a>, and destruct it when it is cleaned up.</p>
<p>The tag string need not be unique between different objects, but it should be unique between an object and its CData object(s). </p>

</div>
</div>
<a id="abd83f808114527e3b7b0a40cab0ca761" name="abd83f808114527e3b7b0a40cab0ca761"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd83f808114527e3b7b0a40cab0ca761">&#9670;&#160;</a></span>set_int_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::set_int_tag </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allows the creating object to store a temporary data value on the <a class="el" href="classBamReader.html">BamReader</a>. This method may be called during an object's fillin() method; it will associate an integer value with an arbitrary string key (which is in turn associated with the calling object only). Later, in the complete_pointers() method, the same object may query this data again via <a class="el" href="classBamReader.html#a2eed6914e03be304c6cf14ea291d97e6">get_int_tag()</a>.</p>
<p>The tag string need not be unique between different objects, but it should be unique between an object and its CData object(s). </p>

</div>
</div>
<a id="a63c44ae63b95a3ddcce8b42ff80ccec7" name="a63c44ae63b95a3ddcce8b42ff80ccec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63c44ae63b95a3ddcce8b42ff80ccec7">&#9670;&#160;</a></span>skip_pointer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::skip_pointer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDatagramIterator.html">DatagramIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>scan</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads and discards a pointer value from the Bam file. This pointer will not be counted among the pointers read for a given object, and will not be in the list of pointers passed to complete_pointers(). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae7d0044dde4a13b80d0e78e53814b894" name="ae7d0044dde4a13b80d0e78e53814b894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d0044dde4a13b80d0e78e53814b894">&#9670;&#160;</a></span>set_source</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void BamReader::set_source</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Changes the source of future datagrams for this <a class="el" href="classBamReader.html">BamReader</a>. This also implicitly calls <a class="el" href="classBamReader.html#a93a91392b652d4096988fd6c093ee128">init()</a> if it has not already been called. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>panda/src/putil/<a class="el" href="bamReader_8h_source.html">bamReader.h</a></li>
<li>panda/src/putil/<a class="el" href="bamReader_8cxx_source.html">bamReader.cxx</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.7
</small></address>
</body>
</html>
